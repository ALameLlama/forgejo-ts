// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseURL: 'https://swagger.json/api/v1' | 'http://swagger.json/api/v1' | (string & {});
};

/**
 * APIError is an api error with a message
 */
export type ApiError = {
    message?: string;
    url?: string;
};

export type ApiForbiddenError = {
    message?: string;
    url?: string;
};

export type ApiInternalServerError = {
    message?: string;
    url?: string;
};

export type ApiInvalidTopicsError = {
    invalidTopics?: Array<string>;
    message?: string;
};

export type ApiNotFound = {
    errors?: Array<string>;
    message?: string;
    url?: string;
};

export type ApiRepoArchivedError = {
    message?: string;
    url?: string;
};

export type ApiUnauthorizedError = {
    message?: string;
    url?: string;
};

export type ApiValidationError = {
    message?: string;
    url?: string;
};

/**
 * AccessToken represents an API access token.
 */
export type AccessToken = {
    id?: number;
    name?: string;
    scopes?: Array<string>;
    sha1?: string;
    token_last_eight?: string;
};

/**
 * ActionRunJob represents a job of a run
 */
export type ActionRunJob = {
    /**
     * the action run job id
     */
    id?: number;
    /**
     * the action run job name
     */
    name?: string;
    /**
     * the action run job needed ids
     */
    needs?: Array<string>;
    /**
     * the owner id
     */
    owner_id?: number;
    /**
     * the repository id
     */
    repo_id?: number;
    /**
     * the action run job labels to run on
     */
    runs_on?: Array<string>;
    /**
     * the action run job status
     */
    status?: string;
    /**
     * the action run job latest task id
     */
    task_id?: number;
};

/**
 * ActionTask represents a ActionTask
 */
export type ActionTask = {
    created_at?: string;
    display_title?: string;
    event?: string;
    head_branch?: string;
    head_sha?: string;
    id?: number;
    name?: string;
    run_number?: number;
    run_started_at?: string;
    status?: string;
    updated_at?: string;
    url?: string;
    workflow_id?: string;
};

/**
 * ActionTaskResponse returns a ActionTask
 */
export type ActionTaskResponse = {
    total_count?: number;
    workflow_runs?: Array<ActionTask>;
};

/**
 * ActionVariable return value of the query API
 */
export type ActionVariable = {
    /**
     * the value of the variable
     */
    data?: string;
    /**
     * the name of the variable
     */
    name?: string;
    /**
     * the owner to which the variable belongs
     */
    owner_id?: number;
    /**
     * the repository to which the variable belongs
     */
    repo_id?: number;
};

export type Activity = {
    act_user?: User;
    act_user_id?: number;
    comment?: Comment;
    comment_id?: number;
    content?: string;
    created?: string;
    id?: number;
    is_private?: boolean;
    /**
     * the type of action
     */
    op_type?: 'create_repo' | 'rename_repo' | 'star_repo' | 'watch_repo' | 'commit_repo' | 'create_issue' | 'create_pull_request' | 'transfer_repo' | 'push_tag' | 'comment_issue' | 'merge_pull_request' | 'close_issue' | 'reopen_issue' | 'close_pull_request' | 'reopen_pull_request' | 'delete_tag' | 'delete_branch' | 'mirror_sync_push' | 'mirror_sync_create' | 'mirror_sync_delete' | 'approve_pull_request' | 'reject_pull_request' | 'comment_pull' | 'publish_release' | 'pull_review_dismissed' | 'pull_request_ready_for_review' | 'auto_merge_pull_request';
    ref_name?: string;
    repo?: Repository;
    repo_id?: number;
    user_id?: number;
};

/**
 * ActivityPub type
 */
export type ActivityPub = {
    '@context'?: string;
};

/**
 * AddCollaboratorOption options when adding a user as a collaborator of a repository
 */
export type AddCollaboratorOption = {
    permission?: 'read' | 'write' | 'admin';
};

/**
 * AddTimeOption options for adding time to an issue
 */
export type AddTimeOption = {
    created?: string;
    /**
     * time in seconds
     */
    time: number;
    /**
     * User who spent the time (optional)
     */
    user_name?: string;
};

/**
 * AnnotatedTag represents an annotated tag
 */
export type AnnotatedTag = {
    archive_download_count?: TagArchiveDownloadCount;
    message?: string;
    object?: AnnotatedTagObject;
    sha?: string;
    tag?: string;
    tagger?: CommitUser;
    url?: string;
    verification?: PayloadCommitVerification;
};

/**
 * AnnotatedTagObject contains meta information of the tag object
 */
export type AnnotatedTagObject = {
    sha?: string;
    type?: string;
    url?: string;
};

/**
 * Attachment a generic attachment
 */
export type Attachment = {
    browser_download_url?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    name?: string;
    size?: number;
    type?: 'attachment' | 'external';
    uuid?: string;
};

/**
 * BlockedUser represents a blocked user.
 */
export type BlockedUser = {
    block_id?: number;
    created_at?: string;
};

/**
 * Branch represents a repository branch
 */
export type Branch = {
    commit?: PayloadCommit;
    effective_branch_protection_name?: string;
    enable_status_check?: boolean;
    name?: string;
    protected?: boolean;
    required_approvals?: number;
    status_check_contexts?: Array<string>;
    user_can_merge?: boolean;
    user_can_push?: boolean;
};

/**
 * BranchProtection represents a branch protection for a repository
 */
export type BranchProtection = {
    apply_to_admins?: boolean;
    approvals_whitelist_teams?: Array<string>;
    approvals_whitelist_username?: Array<string>;
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    /**
     * Deprecated: true
     */
    branch_name?: string;
    created_at?: string;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: Array<string>;
    merge_whitelist_usernames?: Array<string>;
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: Array<string>;
    push_whitelist_usernames?: Array<string>;
    require_signed_commits?: boolean;
    required_approvals?: number;
    rule_name?: string;
    status_check_contexts?: Array<string>;
    unprotected_file_patterns?: string;
    updated_at?: string;
};

/**
 * ChangeFileOperation for creating, updating or deleting a file
 */
export type ChangeFileOperation = {
    /**
     * new or updated file content, must be base64 encoded
     */
    content?: string;
    /**
     * old path of the file to move
     */
    from_path?: string;
    /**
     * indicates what to do with the file
     */
    operation: 'create' | 'update' | 'delete';
    /**
     * path to the existing or new file
     */
    path: string;
    /**
     * sha is the SHA for the file that already exists, required for update or delete
     */
    sha?: string;
};

/**
 * ChangeFilesOptions options for creating, updating or deleting multiple files
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type ChangeFilesOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    dates?: CommitDateOptions;
    /**
     * list of file operations
     */
    files: Array<ChangeFileOperation>;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * ChangedFile store information about files affected by the pull request
 */
export type ChangedFile = {
    additions?: number;
    changes?: number;
    contents_url?: string;
    deletions?: number;
    filename?: string;
    html_url?: string;
    previous_filename?: string;
    raw_url?: string;
    status?: string;
};

/**
 * CombinedStatus holds the combined state of several statuses for a single commit
 */
export type CombinedStatus = {
    commit_url?: string;
    repository?: Repository;
    sha?: string;
    state?: CommitStatusState;
    statuses?: Array<CommitStatus>;
    total_count?: number;
    url?: string;
};

/**
 * Comment represents a comment on a commit or issue
 */
export type Comment = {
    assets?: Array<Attachment>;
    body?: string;
    created_at?: string;
    html_url?: string;
    id?: number;
    issue_url?: string;
    original_author?: string;
    original_author_id?: number;
    pull_request_url?: string;
    updated_at?: string;
    user?: User;
};

/**
 * Commit contains information generated from a Git commit.
 */
export type Commit = {
    author?: User;
    commit?: RepoCommit;
    committer?: User;
    created?: string;
    files?: Array<CommitAffectedFiles>;
    html_url?: string;
    parents?: Array<CommitMeta>;
    sha?: string;
    stats?: CommitStats;
    url?: string;
};

/**
 * CommitAffectedFiles store information about files affected by the commit
 */
export type CommitAffectedFiles = {
    filename?: string;
    status?: string;
};

/**
 * CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE
 */
export type CommitDateOptions = {
    author?: string;
    committer?: string;
};

/**
 * CommitMeta contains meta information of a commit in terms of API.
 */
export type CommitMeta = {
    created?: string;
    sha?: string;
    url?: string;
};

/**
 * CommitStats is statistics for a RepoCommit
 */
export type CommitStats = {
    additions?: number;
    deletions?: number;
    total?: number;
};

/**
 * CommitStatus holds a single status of a single Commit
 */
export type CommitStatus = {
    context?: string;
    created_at?: string;
    creator?: User;
    description?: string;
    id?: number;
    status?: CommitStatusState;
    target_url?: string;
    updated_at?: string;
    url?: string;
};

/**
 * CommitStatusState holds the state of a CommitStatus
 * It can be "pending", "success", "error" and "failure"
 */
export type CommitStatusState = string;

/**
 * CommitUser contains information of a user in the context of a commit.
 */
export type CommitUser = {
    date?: string;
    email?: string;
    name?: string;
};

/**
 * Compare represents a comparison between two commits.
 */
export type Compare = {
    commits?: Array<Commit>;
    files?: Array<CommitAffectedFiles>;
    total_commits?: number;
};

/**
 * ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content
 */
export type ContentsResponse = {
    _links?: FileLinksResponse;
    /**
     * `content` is populated when `type` is `file`, otherwise null
     */
    content?: string;
    download_url?: string;
    /**
     * `encoding` is populated when `type` is `file`, otherwise null
     */
    encoding?: string;
    git_url?: string;
    html_url?: string;
    last_commit_sha?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    /**
     * `submodule_git_url` is populated when `type` is `submodule`, otherwise null
     */
    submodule_git_url?: string;
    /**
     * `target` is populated when `type` is `symlink`, otherwise null
     */
    target?: string;
    /**
     * `type` will be `file`, `dir`, `symlink`, or `submodule`
     */
    type?: string;
    url?: string;
};

/**
 * CreateAccessTokenOption options when create access token
 */
export type CreateAccessTokenOption = {
    name: string;
    scopes?: Array<string>;
};

/**
 * CreateBranchProtectionOption options for creating a branch protection
 */
export type CreateBranchProtectionOption = {
    apply_to_admins?: boolean;
    approvals_whitelist_teams?: Array<string>;
    approvals_whitelist_username?: Array<string>;
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    /**
     * Deprecated: true
     */
    branch_name?: string;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: Array<string>;
    merge_whitelist_usernames?: Array<string>;
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: Array<string>;
    push_whitelist_usernames?: Array<string>;
    require_signed_commits?: boolean;
    required_approvals?: number;
    rule_name?: string;
    status_check_contexts?: Array<string>;
    unprotected_file_patterns?: string;
};

/**
 * CreateBranchRepoOption options when creating a branch in a repository
 */
export type CreateBranchRepoOption = {
    /**
     * Name of the branch to create
     */
    new_branch_name: string;
    /**
     * Deprecated: true
     * Name of the old branch to create from
     */
    old_branch_name?: string;
    /**
     * Name of the old branch/tag/commit to create from
     */
    old_ref_name?: string;
};

/**
 * CreateEmailOption options when creating email addresses
 */
export type CreateEmailOption = {
    /**
     * email addresses to add
     */
    emails?: Array<string>;
};

/**
 * CreateFileOptions options for creating files
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type CreateFileOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    /**
     * content must be base64 encoded
     */
    content: string;
    dates?: CommitDateOptions;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * CreateForkOption options for creating a fork
 */
export type CreateForkOption = {
    /**
     * name of the forked repository
     */
    name?: string;
    /**
     * organization name, if forking into an organization
     */
    organization?: string;
};

/**
 * CreateGPGKeyOption options create user GPG key
 */
export type CreateGpgKeyOption = {
    /**
     * An armored GPG key to add
     */
    armored_public_key: string;
    armored_signature?: string;
};

/**
 * CreateHookOption options when create a hook
 */
export type CreateHookOption = {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config: CreateHookOptionConfig;
    events?: Array<string>;
    type: 'forgejo' | 'dingtalk' | 'discord' | 'gitea' | 'gogs' | 'msteams' | 'slack' | 'telegram' | 'feishu' | 'wechatwork' | 'packagist';
};

/**
 * CreateHookOptionConfig has all config options in it
 * required are "content_type" and "url" Required
 */
export type CreateHookOptionConfig = {
    [key: string]: string;
};

/**
 * CreateIssueCommentOption options for creating a comment on an issue
 */
export type CreateIssueCommentOption = {
    body: string;
    updated_at?: string;
};

/**
 * CreateIssueOption options to create one issue
 */
export type CreateIssueOption = {
    /**
     * deprecated
     */
    assignee?: string;
    assignees?: Array<string>;
    body?: string;
    closed?: boolean;
    due_date?: string;
    /**
     * list of label ids
     */
    labels?: Array<number>;
    /**
     * milestone id
     */
    milestone?: number;
    ref?: string;
    title: string;
};

/**
 * CreateKeyOption options when creating a key
 */
export type CreateKeyOption = {
    /**
     * An armored SSH key to add
     */
    key: string;
    /**
     * Describe if the key has only read access or read/write
     */
    read_only?: boolean;
    /**
     * Title of the key to add
     */
    title: string;
};

/**
 * CreateLabelOption options for creating a label
 */
export type CreateLabelOption = {
    color: string;
    description?: string;
    exclusive?: boolean;
    is_archived?: boolean;
    name: string;
};

/**
 * CreateMilestoneOption options for creating a milestone
 */
export type CreateMilestoneOption = {
    description?: string;
    due_on?: string;
    state?: 'open' | 'closed';
    title?: string;
};

/**
 * CreateOAuth2ApplicationOptions holds options to create an oauth2 application
 */
export type CreateOAuth2ApplicationOptions = {
    confidential_client?: boolean;
    name?: string;
    redirect_uris?: Array<string>;
};

/**
 * CreateOrUpdateSecretOption options when creating or updating secret
 */
export type CreateOrUpdateSecretOption = {
    /**
     * Data of the secret to update
     */
    data: string;
};

/**
 * CreateOrgOption options for creating an organization
 */
export type CreateOrgOption = {
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    repo_admin_change_team_access?: boolean;
    username: string;
    /**
     * possible values are `public` (default), `limited` or `private`
     */
    visibility?: 'public' | 'limited' | 'private';
    website?: string;
};

/**
 * CreatePullRequestOption options when creating a pull request
 */
export type CreatePullRequestOption = {
    assignee?: string;
    assignees?: Array<string>;
    base?: string;
    body?: string;
    due_date?: string;
    head?: string;
    labels?: Array<number>;
    milestone?: number;
    title?: string;
};

/**
 * CreatePullReviewComment represent a review comment for creation api
 */
export type CreatePullReviewComment = {
    body?: string;
    /**
     * if comment to new file line or 0
     */
    new_position?: number;
    /**
     * if comment to old file line or 0
     */
    old_position?: number;
    /**
     * the tree path
     */
    path?: string;
};

export type CreatePullReviewCommentOptions = CreatePullReviewComment;

/**
 * CreatePullReviewOptions are options to create a pull review
 */
export type CreatePullReviewOptions = {
    body?: string;
    comments?: Array<CreatePullReviewComment>;
    commit_id?: string;
    event?: ReviewStateType;
};

/**
 * CreatePushMirrorOption represents need information to create a push mirror of a repository.
 */
export type CreatePushMirrorOption = {
    interval?: string;
    remote_address?: string;
    remote_password?: string;
    remote_username?: string;
    sync_on_commit?: boolean;
    use_ssh?: boolean;
};

/**
 * CreateQutaGroupOptions represents the options for creating a quota group
 */
export type CreateQuotaGroupOptions = {
    /**
     * Name of the quota group to create
     */
    name?: string;
    /**
     * Rules to add to the newly created group.
     * If a rule does not exist, it will be created.
     */
    rules?: Array<CreateQuotaRuleOptions>;
};

/**
 * CreateQuotaRuleOptions represents the options for creating a quota rule
 */
export type CreateQuotaRuleOptions = {
    /**
     * The limit set by the rule
     */
    limit?: number;
    /**
     * Name of the rule to create
     */
    name?: string;
    /**
     * The subjects affected by the rule
     */
    subjects?: Array<string>;
};

/**
 * CreateReleaseOption options when creating a release
 */
export type CreateReleaseOption = {
    body?: string;
    draft?: boolean;
    hide_archive_links?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name: string;
    target_commitish?: string;
};

/**
 * CreateRepoOption options when creating repository
 */
export type CreateRepoOption = {
    /**
     * Whether the repository should be auto-initialized?
     */
    auto_init?: boolean;
    /**
     * DefaultBranch of the repository (used when initializes and in template)
     */
    default_branch?: string;
    /**
     * Description of the repository to create
     */
    description?: string;
    /**
     * Gitignores to use
     */
    gitignores?: string;
    /**
     * Label-Set to use
     */
    issue_labels?: string;
    /**
     * License to use
     */
    license?: string;
    /**
     * Name of the repository to create
     */
    name: string;
    /**
     * ObjectFormatName of the underlying git repository
     */
    object_format_name?: 'sha1' | 'sha256';
    /**
     * Whether the repository is private
     */
    private?: boolean;
    /**
     * Readme of the repository to create
     */
    readme?: string;
    /**
     * Whether the repository is template
     */
    template?: boolean;
    /**
     * TrustModel of the repository
     */
    trust_model?: 'default' | 'collaborator' | 'committer' | 'collaboratorcommitter';
};

/**
 * CreateStatusOption holds the information needed to create a new CommitStatus for a Commit
 */
export type CreateStatusOption = {
    context?: string;
    description?: string;
    state?: CommitStatusState;
    target_url?: string;
};

/**
 * CreateTagOption options when creating a tag
 */
export type CreateTagOption = {
    message?: string;
    tag_name: string;
    target?: string;
};

/**
 * CreateTagProtectionOption options for creating a tag protection
 */
export type CreateTagProtectionOption = {
    name_pattern?: string;
    whitelist_teams?: Array<string>;
    whitelist_usernames?: Array<string>;
};

/**
 * CreateTeamOption options for creating a team
 */
export type CreateTeamOption = {
    can_create_org_repo?: boolean;
    description?: string;
    includes_all_repositories?: boolean;
    name: string;
    permission?: 'read' | 'write' | 'admin';
    units?: Array<string>;
    units_map?: {
        [key: string]: string;
    };
};

/**
 * CreateUserOption create user options
 */
export type CreateUserOption = {
    /**
     * For explicitly setting the user creation timestamp. Useful when users are
     * migrated from other systems. When omitted, the user's creation timestamp
     * will be set to "now".
     */
    created_at?: string;
    email: string;
    full_name?: string;
    login_name?: string;
    must_change_password?: boolean;
    password?: string;
    restricted?: boolean;
    send_notify?: boolean;
    source_id?: number;
    username: string;
    visibility?: string;
};

/**
 * CreateVariableOption the option when creating variable
 */
export type CreateVariableOption = {
    /**
     * Value of the variable to create
     */
    value: string;
};

/**
 * CreateWikiPageOptions form for creating wiki
 */
export type CreateWikiPageOptions = {
    /**
     * content must be base64 encoded
     */
    content_base64?: string;
    /**
     * optional commit message summarizing the change
     */
    message?: string;
    /**
     * page title. leave empty to keep unchanged
     */
    title?: string;
};

/**
 * Cron represents a Cron task
 */
export type Cron = {
    exec_times?: number;
    name?: string;
    next?: string;
    prev?: string;
    schedule?: string;
};

/**
 * DeleteEmailOption options when deleting email addresses
 */
export type DeleteEmailOption = {
    /**
     * email addresses to delete
     */
    emails?: Array<string>;
};

/**
 * DeleteFileOptions options for deleting files (used for other File structs below)
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type DeleteFileOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    dates?: CommitDateOptions;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * sha is the SHA for the file that already exists
     */
    sha: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * DeleteLabelOption options for deleting a label
 */
export type DeleteLabelsOption = {
    updated_at?: string;
};

/**
 * DeployKey a deploy key
 */
export type DeployKey = {
    created_at?: string;
    fingerprint?: string;
    id?: number;
    key?: string;
    key_id?: number;
    read_only?: boolean;
    repository?: Repository;
    title?: string;
    url?: string;
};

/**
 * DismissPullReviewOptions are options to dismiss a pull review
 */
export type DismissPullReviewOptions = {
    message?: string;
    priors?: boolean;
};

/**
 * DispatchWorkflowOption options when dispatching a workflow
 */
export type DispatchWorkflowOption = {
    /**
     * Input keys and values configured in the workflow file.
     */
    inputs?: {
        [key: string]: string;
    };
    /**
     * Git reference for the workflow
     */
    ref: string;
    /**
     * Flag to return the run info
     */
    return_run_info?: boolean;
};

/**
 * DispatchWorkflowRun represents a workflow run
 */
export type DispatchWorkflowRun = {
    /**
     * the workflow run id
     */
    id?: number;
    /**
     * the jobs name
     */
    jobs?: Array<string>;
    /**
     * a unique number for each run of a repository
     */
    run_number?: number;
};

/**
 * EditAttachmentOptions options for editing attachments
 */
export type EditAttachmentOptions = {
    /**
     * (Can only be set if existing attachment is of external type)
     */
    browser_download_url?: string;
    name?: string;
};

/**
 * EditBranchProtectionOption options for editing a branch protection
 */
export type EditBranchProtectionOption = {
    apply_to_admins?: boolean;
    approvals_whitelist_teams?: Array<string>;
    approvals_whitelist_username?: Array<string>;
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: Array<string>;
    merge_whitelist_usernames?: Array<string>;
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: Array<string>;
    push_whitelist_usernames?: Array<string>;
    require_signed_commits?: boolean;
    required_approvals?: number;
    status_check_contexts?: Array<string>;
    unprotected_file_patterns?: string;
};

/**
 * EditDeadlineOption options for creating a deadline
 */
export type EditDeadlineOption = {
    due_date: string;
};

/**
 * EditGitHookOption options when modifying one Git hook
 */
export type EditGitHookOption = {
    content?: string;
};

/**
 * EditHookOption options when modify one hook
 */
export type EditHookOption = {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config?: {
        [key: string]: string;
    };
    events?: Array<string>;
};

/**
 * EditIssueCommentOption options for editing a comment
 */
export type EditIssueCommentOption = {
    body: string;
    updated_at?: string;
};

/**
 * EditIssueOption options for editing an issue
 */
export type EditIssueOption = {
    /**
     * deprecated
     */
    assignee?: string;
    assignees?: Array<string>;
    body?: string;
    due_date?: string;
    milestone?: number;
    ref?: string;
    state?: string;
    title?: string;
    unset_due_date?: boolean;
    updated_at?: string;
};

/**
 * EditLabelOption options for editing a label
 */
export type EditLabelOption = {
    color?: string;
    description?: string;
    exclusive?: boolean;
    is_archived?: boolean;
    name?: string;
};

/**
 * EditMilestoneOption options for editing a milestone
 */
export type EditMilestoneOption = {
    description?: string;
    due_on?: string;
    state?: string;
    title?: string;
};

/**
 * EditOrgOption options for editing an organization
 */
export type EditOrgOption = {
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    repo_admin_change_team_access?: boolean;
    /**
     * possible values are `public`, `limited` or `private`
     */
    visibility?: 'public' | 'limited' | 'private';
    website?: string;
};

/**
 * EditPullRequestOption options when modify pull request
 */
export type EditPullRequestOption = {
    allow_maintainer_edit?: boolean;
    assignee?: string;
    assignees?: Array<string>;
    base?: string;
    body?: string;
    due_date?: string;
    labels?: Array<number>;
    milestone?: number;
    state?: string;
    title?: string;
    unset_due_date?: boolean;
};

/**
 * EditQuotaRuleOptions represents the options for editing a quota rule
 */
export type EditQuotaRuleOptions = {
    /**
     * The limit set by the rule
     */
    limit?: number;
    /**
     * The subjects affected by the rule
     */
    subjects?: Array<string>;
};

/**
 * EditReactionOption contain the reaction type
 */
export type EditReactionOption = {
    content?: string;
};

/**
 * EditReleaseOption options when editing a release
 */
export type EditReleaseOption = {
    body?: string;
    draft?: boolean;
    hide_archive_links?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name?: string;
    target_commitish?: string;
};

/**
 * EditRepoOption options when editing a repository's properties
 */
export type EditRepoOption = {
    /**
     * either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging.
     */
    allow_fast_forward_only_merge?: boolean;
    /**
     * either `true` to allow mark pr as merged manually, or `false` to prevent it.
     */
    allow_manual_merge?: boolean;
    /**
     * either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
     */
    allow_merge_commits?: boolean;
    /**
     * either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
     */
    allow_rebase?: boolean;
    /**
     * either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.
     */
    allow_rebase_explicit?: boolean;
    /**
     * either `true` to allow updating pull request branch by rebase, or `false` to prevent it.
     */
    allow_rebase_update?: boolean;
    /**
     * either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
     */
    allow_squash_merge?: boolean;
    /**
     * set to `true` to archive this repository.
     */
    archived?: boolean;
    /**
     * either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.
     */
    autodetect_manual_merge?: boolean;
    /**
     * set to `true` to allow edits from maintainers by default
     */
    default_allow_maintainer_edit?: boolean;
    /**
     * sets the default branch for this repository.
     */
    default_branch?: string;
    /**
     * set to `true` to delete pr branch after merge by default
     */
    default_delete_branch_after_merge?: boolean;
    /**
     * set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", "fast-forward-only", "manually-merged", or "rebase-update-only".
     */
    default_merge_style?: string;
    /**
     * set to a update style to be used by this repository: "rebase" or "merge"
     */
    default_update_style?: string;
    /**
     * a short description of the repository.
     */
    description?: string;
    /**
     * enable prune - remove obsolete remote-tracking references when mirroring
     */
    enable_prune?: boolean;
    external_tracker?: ExternalTracker;
    external_wiki?: ExternalWiki;
    /**
     * set the globally editable state of the wiki
     */
    globally_editable_wiki?: boolean;
    /**
     * either `true` to enable actions unit, or `false` to disable them.
     */
    has_actions?: boolean;
    /**
     * either `true` to enable issues for this repository or `false` to disable them.
     */
    has_issues?: boolean;
    /**
     * either `true` to enable packages unit, or `false` to disable them.
     */
    has_packages?: boolean;
    /**
     * either `true` to enable project unit, or `false` to disable them.
     */
    has_projects?: boolean;
    /**
     * either `true` to allow pull requests, or `false` to prevent pull request.
     */
    has_pull_requests?: boolean;
    /**
     * either `true` to enable releases unit, or `false` to disable them.
     */
    has_releases?: boolean;
    /**
     * either `true` to enable the wiki for this repository or `false` to disable it.
     */
    has_wiki?: boolean;
    /**
     * either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.
     */
    ignore_whitespace_conflicts?: boolean;
    internal_tracker?: InternalTracker;
    /**
     * set to a string like `8h30m0s` to set the mirror interval time
     */
    mirror_interval?: string;
    /**
     * name of the repository
     */
    name?: string;
    /**
     * either `true` to make the repository private or `false` to make it public.
     * Note: you will get a 422 error if the organization restricts changing repository visibility to organization
     * owners and a non-owner tries to change the value of private.
     */
    private?: boolean;
    /**
     * either `true` to make this repository a template or `false` to make it a normal repository
     */
    template?: boolean;
    /**
     * a URL with more information about the repository.
     */
    website?: string;
    /**
     * sets the branch used for this repository's wiki.
     */
    wiki_branch?: string;
};

/**
 * EditTagProtectionOption options for editing a tag protection
 */
export type EditTagProtectionOption = {
    name_pattern?: string;
    whitelist_teams?: Array<string>;
    whitelist_usernames?: Array<string>;
};

/**
 * EditTeamOption options for editing a team
 */
export type EditTeamOption = {
    can_create_org_repo?: boolean;
    description?: string;
    includes_all_repositories?: boolean;
    name: string;
    permission?: 'read' | 'write' | 'admin';
    units?: Array<string>;
    units_map?: {
        [key: string]: string;
    };
};

/**
 * EditUserOption edit user options
 */
export type EditUserOption = {
    active?: boolean;
    admin?: boolean;
    allow_create_organization?: boolean;
    allow_git_hook?: boolean;
    allow_import_local?: boolean;
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    login_name?: string;
    max_repo_creation?: number;
    must_change_password?: boolean;
    password?: string;
    prohibit_login?: boolean;
    pronouns?: string;
    restricted?: boolean;
    source_id?: number;
    visibility?: string;
    website?: string;
};

/**
 * Email an email address belonging to a user
 */
export type Email = {
    email?: string;
    primary?: boolean;
    user_id?: number;
    username?: string;
    verified?: boolean;
};

/**
 * ExternalTracker represents settings for external tracker
 */
export type ExternalTracker = {
    /**
     * External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.
     */
    external_tracker_format?: string;
    /**
     * External Issue Tracker issue regular expression
     */
    external_tracker_regexp_pattern?: string;
    /**
     * External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp`
     */
    external_tracker_style?: string;
    /**
     * URL of external issue tracker.
     */
    external_tracker_url?: string;
};

/**
 * ExternalWiki represents setting for external wiki
 */
export type ExternalWiki = {
    /**
     * URL of external wiki.
     */
    external_wiki_url?: string;
};

/**
 * FileCommitResponse contains information generated from a Git commit for a repo's file.
 */
export type FileCommitResponse = {
    author?: CommitUser;
    committer?: CommitUser;
    created?: string;
    html_url?: string;
    message?: string;
    parents?: Array<CommitMeta>;
    sha?: string;
    tree?: CommitMeta;
    url?: string;
};

/**
 * FileDeleteResponse contains information about a repo's file that was deleted
 */
export type FileDeleteResponse = {
    commit?: FileCommitResponse;
    content?: unknown;
    verification?: PayloadCommitVerification;
};

/**
 * FileLinksResponse contains the links for a repo's file
 */
export type FileLinksResponse = {
    git?: string;
    html?: string;
    self?: string;
};

/**
 * FileResponse contains information about a repo's file
 */
export type FileResponse = {
    commit?: FileCommitResponse;
    content?: ContentsResponse;
    verification?: PayloadCommitVerification;
};

/**
 * FilesResponse contains information about multiple files from a repo
 */
export type FilesResponse = {
    commit?: FileCommitResponse;
    files?: Array<ContentsResponse>;
    verification?: PayloadCommitVerification;
};

/**
 * ForgeLike activity data type
 */
export type ForgeLike = {
    [key: string]: unknown;
};

/**
 * GPGKey a user GPG key to sign commit and tag in repository
 */
export type GpgKey = {
    can_certify?: boolean;
    can_encrypt_comms?: boolean;
    can_encrypt_storage?: boolean;
    can_sign?: boolean;
    created_at?: string;
    emails?: Array<GpgKeyEmail>;
    expires_at?: string;
    id?: number;
    key_id?: string;
    primary_key_id?: string;
    public_key?: string;
    subkeys?: Array<GpgKey>;
    verified?: boolean;
};

/**
 * GPGKeyEmail an email attached to a GPGKey
 */
export type GpgKeyEmail = {
    email?: string;
    verified?: boolean;
};

/**
 * GeneralAPISettings contains global api settings exposed by it
 */
export type GeneralApiSettings = {
    default_git_trees_per_page?: number;
    default_max_blob_size?: number;
    default_paging_num?: number;
    max_response_items?: number;
};

/**
 * GeneralAttachmentSettings contains global Attachment settings exposed by API
 */
export type GeneralAttachmentSettings = {
    allowed_types?: string;
    enabled?: boolean;
    max_files?: number;
    max_size?: number;
};

/**
 * GeneralRepoSettings contains global repository settings exposed by API
 */
export type GeneralRepoSettings = {
    forks_disabled?: boolean;
    http_git_disabled?: boolean;
    lfs_disabled?: boolean;
    migrations_disabled?: boolean;
    mirrors_disabled?: boolean;
    stars_disabled?: boolean;
    time_tracking_disabled?: boolean;
};

/**
 * GeneralUISettings contains global ui settings exposed by API
 */
export type GeneralUiSettings = {
    allowed_reactions?: Array<string>;
    custom_emojis?: Array<string>;
    default_theme?: string;
};

/**
 * GenerateRepoOption options when creating repository using a template
 */
export type GenerateRepoOption = {
    /**
     * include avatar of the template repo
     */
    avatar?: boolean;
    /**
     * Default branch of the new repository
     */
    default_branch?: string;
    /**
     * Description of the repository to create
     */
    description?: string;
    /**
     * include git content of default branch in template repo
     */
    git_content?: boolean;
    /**
     * include git hooks in template repo
     */
    git_hooks?: boolean;
    /**
     * include labels in template repo
     */
    labels?: boolean;
    /**
     * Name of the repository to create
     */
    name: string;
    /**
     * The organization or person who will own the new repository
     */
    owner: string;
    /**
     * Whether the repository is private
     */
    private?: boolean;
    /**
     * include protected branches in template repo
     */
    protected_branch?: boolean;
    /**
     * include topics in template repo
     */
    topics?: boolean;
    /**
     * include webhooks in template repo
     */
    webhooks?: boolean;
};

/**
 * GitBlobResponse represents a git blob
 */
export type GitBlobResponse = {
    content?: string;
    encoding?: string;
    sha?: string;
    size?: number;
    url?: string;
};

/**
 * GitEntry represents a git tree
 */
export type GitEntry = {
    mode?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;
};

/**
 * GitHook represents a Git repository hook
 */
export type GitHook = {
    content?: string;
    is_active?: boolean;
    name?: string;
};

/**
 * GitObject represents a Git object.
 */
export type GitObject = {
    sha?: string;
    type?: string;
    url?: string;
};

/**
 * GitTreeResponse returns a git tree
 */
export type GitTreeResponse = {
    page?: number;
    sha?: string;
    total_count?: number;
    tree?: Array<GitEntry>;
    truncated?: boolean;
    url?: string;
};

/**
 * GitignoreTemplateInfo name and text of a gitignore template
 */
export type GitignoreTemplateInfo = {
    name?: string;
    source?: string;
};

/**
 * Hook a hook is a web hook when one repository changed
 */
export type Hook = {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    /**
     * Deprecated: use Metadata instead
     */
    config?: {
        [key: string]: string;
    };
    content_type?: string;
    created_at?: string;
    events?: Array<string>;
    id?: number;
    metadata?: unknown;
    type?: string;
    updated_at?: string;
    url?: string;
};

/**
 * Identity for a person's identity like an author or committer
 */
export type Identity = {
    email?: string;
    name?: string;
};

/**
 * InternalTracker represents settings for internal tracker
 */
export type InternalTracker = {
    /**
     * Let only contributors track time (Built-in issue tracker)
     */
    allow_only_contributors_to_track_time?: boolean;
    /**
     * Enable dependencies for issues and pull requests (Built-in issue tracker)
     */
    enable_issue_dependencies?: boolean;
    /**
     * Enable time tracking (Built-in issue tracker)
     */
    enable_time_tracker?: boolean;
};

/**
 * Issue represents an issue in a repository
 */
export type Issue = {
    assets?: Array<Attachment>;
    assignee?: User;
    assignees?: Array<User>;
    body?: string;
    closed_at?: string;
    comments?: number;
    created_at?: string;
    due_date?: string;
    html_url?: string;
    id?: number;
    is_locked?: boolean;
    labels?: Array<Label>;
    milestone?: Milestone;
    number?: number;
    original_author?: string;
    original_author_id?: number;
    pin_order?: number;
    pull_request?: PullRequestMeta;
    ref?: string;
    repository?: RepositoryMeta;
    state?: StateType;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: User;
};

export type IssueConfig = {
    blank_issues_enabled?: boolean;
    contact_links?: Array<IssueConfigContactLink>;
};

export type IssueConfigContactLink = {
    about?: string;
    name?: string;
    url?: string;
};

export type IssueConfigValidation = {
    message?: string;
    valid?: boolean;
};

/**
 * IssueDeadline represents an issue deadline
 */
export type IssueDeadline = {
    due_date?: string;
};

/**
 * IssueFormField represents a form field
 */
export type IssueFormField = {
    attributes?: {
        [key: string]: unknown;
    };
    id?: string;
    type?: IssueFormFieldType;
    validations?: {
        [key: string]: unknown;
    };
    visible?: Array<IssueFormFieldVisible>;
};

/**
 * IssueFormFieldType defines issue form field type, can be "markdown", "textarea", "input", "dropdown" or "checkboxes"
 */
export type IssueFormFieldType = string;

/**
 * IssueFormFieldVisible defines issue form field visible
 */
export type IssueFormFieldVisible = string;

/**
 * IssueLabelsOption a collection of labels
 */
export type IssueLabelsOption = {
    /**
     * Labels can be a list of integers representing label IDs
     * or a list of strings representing label names
     */
    labels?: Array<unknown>;
    updated_at?: string;
};

/**
 * IssueMeta basic issue information
 */
export type IssueMeta = {
    index?: number;
    owner?: string;
    repo?: string;
};

/**
 * IssueTemplate represents an issue template for a repository
 */
export type IssueTemplate = {
    about?: string;
    body?: Array<IssueFormField>;
    content?: string;
    file_name?: string;
    labels?: IssueTemplateLabels;
    name?: string;
    ref?: string;
    title?: string;
};

export type IssueTemplateLabels = Array<string>;

/**
 * Label a label to an issue or a pr
 */
export type Label = {
    color?: string;
    description?: string;
    exclusive?: boolean;
    id?: number;
    is_archived?: boolean;
    name?: string;
    url?: string;
};

/**
 * LabelTemplate info of a Label template
 */
export type LabelTemplate = {
    color?: string;
    description?: string;
    exclusive?: boolean;
    name?: string;
};

/**
 * LicensesInfo contains information about a License
 */
export type LicenseTemplateInfo = {
    body?: string;
    implementation?: string;
    key?: string;
    name?: string;
    url?: string;
};

/**
 * LicensesListEntry is used for the API
 */
export type LicensesTemplateListEntry = {
    key?: string;
    name?: string;
    url?: string;
};

/**
 * MarkdownOption markdown options
 */
export type MarkdownOption = {
    /**
     * Context to render
     *
     * in: body
     */
    Context?: string;
    /**
     * Mode to render (comment, gfm, markdown)
     *
     * in: body
     */
    Mode?: string;
    /**
     * Text markdown to render
     *
     * in: body
     */
    Text?: string;
    /**
     * Is it a wiki page ?
     *
     * in: body
     */
    Wiki?: boolean;
};

/**
 * MarkupOption markup options
 */
export type MarkupOption = {
    /**
     * The current branch path where the form gets posted
     *
     * in: body
     */
    BranchPath?: string;
    /**
     * Context to render
     *
     * in: body
     */
    Context?: string;
    /**
     * File path for detecting extension in file mode
     *
     * in: body
     */
    FilePath?: string;
    /**
     * Mode to render (comment, gfm, markdown, file)
     *
     * in: body
     */
    Mode?: string;
    /**
     * Text markup to render
     *
     * in: body
     */
    Text?: string;
    /**
     * Is it a wiki page ?
     *
     * in: body
     */
    Wiki?: boolean;
};

/**
 * MergePullRequestForm form for merging Pull Request
 */
export type MergePullRequestOption = {
    Do: 'merge' | 'rebase' | 'rebase-merge' | 'squash' | 'fast-forward-only' | 'manually-merged';
    MergeCommitID?: string;
    MergeMessageField?: string;
    MergeTitleField?: string;
    delete_branch_after_merge?: boolean;
    force_merge?: boolean;
    head_commit_id?: string;
    merge_when_checks_succeed?: boolean;
};

/**
 * MigrateRepoOptions options for migrating repository's
 * this is used to interact with api v1
 */
export type MigrateRepoOptions = {
    auth_password?: string;
    auth_token?: string;
    auth_username?: string;
    clone_addr: string;
    description?: string;
    issues?: boolean;
    labels?: boolean;
    lfs?: boolean;
    lfs_endpoint?: string;
    milestones?: boolean;
    mirror?: boolean;
    mirror_interval?: string;
    private?: boolean;
    pull_requests?: boolean;
    releases?: boolean;
    repo_name: string;
    /**
     * Name of User or Organisation who will own Repo after migration
     */
    repo_owner?: string;
    service?: 'git' | 'github' | 'gitea' | 'gitlab' | 'gogs' | 'onedev' | 'gitbucket' | 'codebase';
    /**
     * deprecated (only for backwards compatibility)
     */
    uid?: number;
    wiki?: boolean;
};

/**
 * Milestone milestone is a collection of issues on one repository
 */
export type Milestone = {
    closed_at?: string;
    closed_issues?: number;
    created_at?: string;
    description?: string;
    due_on?: string;
    id?: number;
    open_issues?: number;
    state?: StateType;
    title?: string;
    updated_at?: string;
};

/**
 * NewIssuePinsAllowed represents an API response that says if new Issue Pins are allowed
 */
export type NewIssuePinsAllowed = {
    issues?: boolean;
    pull_requests?: boolean;
};

/**
 * NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks
 */
export type NodeInfo = {
    metadata?: {
        [key: string]: unknown;
    };
    openRegistrations?: boolean;
    protocols?: Array<string>;
    services?: NodeInfoServices;
    software?: NodeInfoSoftware;
    usage?: NodeInfoUsage;
    version?: string;
};

/**
 * NodeInfoServices contains the third party sites this server can connect to via their application API
 */
export type NodeInfoServices = {
    inbound?: Array<string>;
    outbound?: Array<string>;
};

/**
 * NodeInfoSoftware contains Metadata about server software in use
 */
export type NodeInfoSoftware = {
    homepage?: string;
    name?: string;
    repository?: string;
    version?: string;
};

/**
 * NodeInfoUsage contains usage statistics for this server
 */
export type NodeInfoUsage = {
    localComments?: number;
    localPosts?: number;
    users?: NodeInfoUsageUsers;
};

/**
 * NodeInfoUsageUsers contains statistics about the users of this server
 */
export type NodeInfoUsageUsers = {
    activeHalfyear?: number;
    activeMonth?: number;
    total?: number;
};

/**
 * Note contains information related to a git note
 */
export type Note = {
    commit?: Commit;
    message?: string;
};

export type NoteOptions = {
    message?: string;
};

/**
 * NotificationCount number of unread notifications
 */
export type NotificationCount = {
    new?: number;
};

/**
 * NotificationSubject contains the notification subject (Issue/Pull/Commit)
 */
export type NotificationSubject = {
    html_url?: string;
    latest_comment_html_url?: string;
    latest_comment_url?: string;
    state?: StateType;
    title?: string;
    type?: NotifySubjectType;
    url?: string;
};

/**
 * NotificationThread expose Notification on API
 */
export type NotificationThread = {
    id?: number;
    pinned?: boolean;
    repository?: Repository;
    subject?: NotificationSubject;
    unread?: boolean;
    updated_at?: string;
    url?: string;
};

/**
 * NotifySubjectType represent type of notification subject
 */
export type NotifySubjectType = string;

/**
 * OAuth2Application represents an OAuth2 application.
 */
export type OAuth2Application = {
    client_id?: string;
    client_secret?: string;
    confidential_client?: boolean;
    created?: string;
    id?: number;
    name?: string;
    redirect_uris?: Array<string>;
};

/**
 * Organization represents an organization
 */
export type Organization = {
    avatar_url?: string;
    description?: string;
    email?: string;
    full_name?: string;
    id?: number;
    location?: string;
    name?: string;
    repo_admin_change_team_access?: boolean;
    /**
     * deprecated
     */
    username?: string;
    visibility?: string;
    website?: string;
};

/**
 * OrganizationPermissions list different users permissions on an organization
 */
export type OrganizationPermissions = {
    can_create_repository?: boolean;
    can_read?: boolean;
    can_write?: boolean;
    is_admin?: boolean;
    is_owner?: boolean;
};

/**
 * PRBranchInfo information about a branch
 */
export type PrBranchInfo = {
    label?: string;
    ref?: string;
    repo?: Repository;
    repo_id?: number;
    sha?: string;
};

/**
 * Package represents a package
 */
export type Package = {
    created_at?: string;
    creator?: User;
    html_url?: string;
    id?: number;
    name?: string;
    owner?: User;
    repository?: Repository;
    type?: string;
    version?: string;
};

/**
 * PackageFile represents a package file
 */
export type PackageFile = {
    Size?: number;
    id?: number;
    md5?: string;
    name?: string;
    sha1?: string;
    sha256?: string;
    sha512?: string;
};

/**
 * PayloadCommit represents a commit
 */
export type PayloadCommit = {
    added?: Array<string>;
    author?: PayloadUser;
    committer?: PayloadUser;
    /**
     * sha1 hash of the commit
     */
    id?: string;
    message?: string;
    modified?: Array<string>;
    removed?: Array<string>;
    timestamp?: string;
    url?: string;
    verification?: PayloadCommitVerification;
};

/**
 * PayloadCommitVerification represents the GPG verification of a commit
 */
export type PayloadCommitVerification = {
    payload?: string;
    reason?: string;
    signature?: string;
    signer?: PayloadUser;
    verified?: boolean;
};

/**
 * PayloadUser represents the author or committer of a commit
 */
export type PayloadUser = {
    email?: string;
    /**
     * Full name of the commit author
     */
    name?: string;
    username?: string;
};

/**
 * Permission represents a set of permissions
 */
export type Permission = {
    admin?: boolean;
    pull?: boolean;
    push?: boolean;
};

/**
 * PublicKey publickey is a user key to push code to repository
 */
export type PublicKey = {
    created_at?: string;
    fingerprint?: string;
    id?: number;
    key?: string;
    key_type?: string;
    read_only?: boolean;
    title?: string;
    url?: string;
    user?: User;
};

/**
 * PullRequest represents a pull request
 */
export type PullRequest = {
    additions?: number;
    allow_maintainer_edit?: boolean;
    assignee?: User;
    assignees?: Array<User>;
    base?: PrBranchInfo;
    body?: string;
    changed_files?: number;
    closed_at?: string;
    comments?: number;
    created_at?: string;
    deletions?: number;
    diff_url?: string;
    draft?: boolean;
    due_date?: string;
    flow?: number;
    head?: PrBranchInfo;
    html_url?: string;
    id?: number;
    is_locked?: boolean;
    labels?: Array<Label>;
    merge_base?: string;
    merge_commit_sha?: string;
    mergeable?: boolean;
    merged?: boolean;
    merged_at?: string;
    merged_by?: User;
    milestone?: Milestone;
    number?: number;
    patch_url?: string;
    pin_order?: number;
    requested_reviewers?: Array<User>;
    requested_reviewers_teams?: Array<Team>;
    /**
     * number of review comments made on the diff of a PR review (not including comments on commits or issues in a PR)
     */
    review_comments?: number;
    state?: StateType;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: User;
};

/**
 * PullRequestMeta PR info if an issue is a PR
 */
export type PullRequestMeta = {
    draft?: boolean;
    html_url?: string;
    merged?: boolean;
    merged_at?: string;
};

/**
 * PullReview represents a pull request review
 */
export type PullReview = {
    body?: string;
    comments_count?: number;
    commit_id?: string;
    dismissed?: boolean;
    html_url?: string;
    id?: number;
    official?: boolean;
    pull_request_url?: string;
    stale?: boolean;
    state?: ReviewStateType;
    submitted_at?: string;
    team?: Team;
    updated_at?: string;
    user?: User;
};

/**
 * PullReviewComment represents a comment on a pull request review
 */
export type PullReviewComment = {
    body?: string;
    commit_id?: string;
    created_at?: string;
    diff_hunk?: string;
    html_url?: string;
    id?: number;
    original_commit_id?: string;
    original_position?: number;
    path?: string;
    position?: number;
    pull_request_review_id?: number;
    pull_request_url?: string;
    resolver?: User;
    updated_at?: string;
    user?: User;
};

/**
 * PullReviewRequestOptions are options to add or remove pull review requests
 */
export type PullReviewRequestOptions = {
    reviewers?: Array<string>;
    team_reviewers?: Array<string>;
};

/**
 * PushMirror represents information of a push mirror
 */
export type PushMirror = {
    created?: string;
    interval?: string;
    last_error?: string;
    last_update?: string;
    public_key?: string;
    remote_address?: string;
    remote_name?: string;
    repo_name?: string;
    sync_on_commit?: boolean;
};

/**
 * QuotaGroup represents a quota group
 */
export type QuotaGroup = {
    /**
     * Name of the group
     */
    name?: string;
    /**
     * Rules associated with the group
     */
    rules?: Array<QuotaRuleInfo>;
};

/**
 * QuotaGroupList represents a list of quota groups
 */
export type QuotaGroupList = Array<QuotaGroup>;

/**
 * QuotaInfo represents information about a user's quota
 */
export type QuotaInfo = {
    groups?: QuotaGroupList;
    used?: QuotaUsed;
};

/**
 * QuotaRuleInfo contains information about a quota rule
 */
export type QuotaRuleInfo = {
    /**
     * The limit set by the rule
     */
    limit?: number;
    /**
     * Name of the rule (only shown to admins)
     */
    name?: string;
    /**
     * Subjects the rule affects
     */
    subjects?: Array<string>;
};

/**
 * QuotaUsed represents the quota usage of a user
 */
export type QuotaUsed = {
    size?: QuotaUsedSize;
};

/**
 * QuotaUsedArtifact represents an artifact counting towards a user's quota
 */
export type QuotaUsedArtifact = {
    /**
     * HTML URL to the action run containing the artifact
     */
    html_url?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * Size of the artifact (compressed)
     */
    size?: number;
};

/**
 * QuotaUsedArtifactList represents a list of artifacts counting towards a user's quota
 */
export type QuotaUsedArtifactList = Array<QuotaUsedArtifact>;

/**
 * QuotaUsedAttachment represents an attachment counting towards a user's quota
 */
export type QuotaUsedAttachment = {
    /**
     * API URL for the attachment
     */
    api_url?: string;
    /**
     * Context for the attachment: URLs to the containing object
     */
    contained_in?: {
        /**
         * API URL for the object that contains this attachment
         */
        api_url?: string;
        /**
         * HTML URL for the object that contains this attachment
         */
        html_url?: string;
    };
    /**
     * Filename of the attachment
     */
    name?: string;
    /**
     * Size of the attachment (in bytes)
     */
    size?: number;
};

/**
 * QuotaUsedAttachmentList represents a list of attachment counting towards a user's quota
 */
export type QuotaUsedAttachmentList = Array<QuotaUsedAttachment>;

/**
 * QuotaUsedPackage represents a package counting towards a user's quota
 */
export type QuotaUsedPackage = {
    /**
     * HTML URL to the package version
     */
    html_url?: string;
    /**
     * Name of the package
     */
    name?: string;
    /**
     * Size of the package version
     */
    size?: number;
    /**
     * Type of the package
     */
    type?: string;
    /**
     * Version of the package
     */
    version?: string;
};

/**
 * QuotaUsedPackageList represents a list of packages counting towards a user's quota
 */
export type QuotaUsedPackageList = Array<QuotaUsedPackage>;

/**
 * QuotaUsedSize represents the size-based quota usage of a user
 */
export type QuotaUsedSize = {
    assets?: QuotaUsedSizeAssets;
    git?: QuotaUsedSizeGit;
    repos?: QuotaUsedSizeRepos;
};

/**
 * QuotaUsedSizeAssets represents the size-based asset usage of a user
 */
export type QuotaUsedSizeAssets = {
    /**
     * Storage size used for the user's artifacts
     */
    artifacts?: number;
    attachments?: QuotaUsedSizeAssetsAttachments;
    packages?: QuotaUsedSizeAssetsPackages;
};

/**
 * QuotaUsedSizeAssetsAttachments represents the size-based attachment quota usage of a user
 */
export type QuotaUsedSizeAssetsAttachments = {
    /**
     * Storage size used for the user's issue & comment attachments
     */
    issues?: number;
    /**
     * Storage size used for the user's release attachments
     */
    releases?: number;
};

/**
 * QuotaUsedSizeAssetsPackages represents the size-based package quota usage of a user
 */
export type QuotaUsedSizeAssetsPackages = {
    /**
     * Storage suze used for the user's packages
     */
    all?: number;
};

/**
 * QuotaUsedSizeGit represents the size-based git (lfs) quota usage of a user
 */
export type QuotaUsedSizeGit = {
    /**
     * Storage size of the user's Git LFS objects
     */
    LFS?: number;
};

/**
 * QuotaUsedSizeRepos represents the size-based repository quota usage of a user
 */
export type QuotaUsedSizeRepos = {
    /**
     * Storage size of the user's private repositories
     */
    private?: number;
    /**
     * Storage size of the user's public repositories
     */
    public?: number;
};

/**
 * Reaction contain one reaction
 */
export type Reaction = {
    content?: string;
    created_at?: string;
    user?: User;
};

/**
 * Reference represents a Git reference.
 */
export type Reference = {
    object?: GitObject;
    ref?: string;
    url?: string;
};

/**
 * Release represents a repository release
 */
export type Release = {
    archive_download_count?: TagArchiveDownloadCount;
    assets?: Array<Attachment>;
    author?: User;
    body?: string;
    created_at?: string;
    draft?: boolean;
    hide_archive_links?: boolean;
    html_url?: string;
    id?: number;
    name?: string;
    prerelease?: boolean;
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;
};

/**
 * RenameOrgOption options when renaming an organization
 */
export type RenameOrgOption = {
    /**
     * New username for this org. This name cannot be in use yet by any other user.
     */
    new_name: string;
};

/**
 * RenameUserOption options when renaming a user
 */
export type RenameUserOption = {
    /**
     * New username for this user. This name cannot be in use yet by any other user.
     */
    new_username: string;
};

/**
 * ReplaceFlagsOption options when replacing the flags of a repository
 */
export type ReplaceFlagsOption = {
    flags?: Array<string>;
};

/**
 * RepoCollaboratorPermission to get repository permission for a collaborator
 */
export type RepoCollaboratorPermission = {
    permission?: string;
    role_name?: string;
    user?: User;
};

/**
 * RepoCommit contains information of a commit in the context of a repository.
 */
export type RepoCommit = {
    author?: CommitUser;
    committer?: CommitUser;
    message?: string;
    tree?: CommitMeta;
    url?: string;
    verification?: PayloadCommitVerification;
};

/**
 * RepoTopicOptions a collection of repo topic names
 */
export type RepoTopicOptions = {
    /**
     * list of topic names
     */
    topics?: Array<string>;
};

/**
 * RepoTransfer represents a pending repo transfer
 */
export type RepoTransfer = {
    doer?: User;
    recipient?: User;
    teams?: Array<Team>;
};

/**
 * Repository represents a repository
 */
export type Repository = {
    allow_fast_forward_only_merge?: boolean;
    allow_merge_commits?: boolean;
    allow_rebase?: boolean;
    allow_rebase_explicit?: boolean;
    allow_rebase_update?: boolean;
    allow_squash_merge?: boolean;
    archived?: boolean;
    archived_at?: string;
    avatar_url?: string;
    clone_url?: string;
    created_at?: string;
    default_allow_maintainer_edit?: boolean;
    default_branch?: string;
    default_delete_branch_after_merge?: boolean;
    default_merge_style?: string;
    default_update_style?: string;
    description?: string;
    empty?: boolean;
    external_tracker?: ExternalTracker;
    external_wiki?: ExternalWiki;
    fork?: boolean;
    forks_count?: number;
    full_name?: string;
    globally_editable_wiki?: boolean;
    has_actions?: boolean;
    has_issues?: boolean;
    has_packages?: boolean;
    has_projects?: boolean;
    has_pull_requests?: boolean;
    has_releases?: boolean;
    has_wiki?: boolean;
    html_url?: string;
    id?: number;
    ignore_whitespace_conflicts?: boolean;
    internal?: boolean;
    internal_tracker?: InternalTracker;
    language?: string;
    languages_url?: string;
    link?: string;
    mirror?: boolean;
    mirror_interval?: string;
    mirror_updated?: string;
    name?: string;
    /**
     * ObjectFormatName of the underlying git repository
     */
    object_format_name?: 'sha1' | 'sha256';
    open_issues_count?: number;
    open_pr_counter?: number;
    original_url?: string;
    owner?: User;
    parent?: Repository;
    permissions?: Permission;
    private?: boolean;
    release_counter?: number;
    repo_transfer?: RepoTransfer;
    size?: number;
    ssh_url?: string;
    stars_count?: number;
    template?: boolean;
    topics?: Array<string>;
    updated_at?: string;
    url?: string;
    watchers_count?: number;
    website?: string;
    wiki_branch?: string;
};

/**
 * RepositoryMeta basic repository information
 */
export type RepositoryMeta = {
    full_name?: string;
    id?: number;
    name?: string;
    owner?: string;
};

/**
 * ReviewStateType review state type
 */
export type ReviewStateType = string;

/**
 * SearchResults results of a successful search
 */
export type SearchResults = {
    data?: Array<Repository>;
    ok?: boolean;
};

/**
 * Secret represents a secret
 */
export type Secret = {
    created_at?: string;
    /**
     * the secret's name
     */
    name?: string;
};

/**
 * ServerVersion wraps the version of the server
 */
export type ServerVersion = {
    version?: string;
};

/**
 * SetUserQuotaGroupsOptions represents the quota groups of a user
 */
export type SetUserQuotaGroupsOptions = {
    /**
     * Quota groups the user shall have
     */
    groups: Array<string>;
};

/**
 * StateType issue state type
 */
export type StateType = string;

/**
 * StopWatch represent a running stopwatch
 */
export type StopWatch = {
    created?: string;
    duration?: string;
    issue_index?: number;
    issue_title?: string;
    repo_name?: string;
    repo_owner_name?: string;
    seconds?: number;
};

/**
 * SubmitPullReviewOptions are options to submit a pending pull review
 */
export type SubmitPullReviewOptions = {
    body?: string;
    event?: ReviewStateType;
};

/**
 * Tag represents a repository tag
 */
export type Tag = {
    archive_download_count?: TagArchiveDownloadCount;
    commit?: CommitMeta;
    id?: string;
    message?: string;
    name?: string;
    tarball_url?: string;
    zipball_url?: string;
};

/**
 * TagArchiveDownloadCount counts how many times a archive was downloaded
 */
export type TagArchiveDownloadCount = {
    tar_gz?: number;
    zip?: number;
};

/**
 * TagProtection represents a tag protection
 */
export type TagProtection = {
    created_at?: string;
    id?: number;
    name_pattern?: string;
    updated_at?: string;
    whitelist_teams?: Array<string>;
    whitelist_usernames?: Array<string>;
};

/**
 * Team represents a team in an organization
 */
export type Team = {
    can_create_org_repo?: boolean;
    description?: string;
    id?: number;
    includes_all_repositories?: boolean;
    name?: string;
    organization?: Organization;
    permission?: 'none' | 'read' | 'write' | 'admin' | 'owner';
    units?: Array<string>;
    units_map?: {
        [key: string]: string;
    };
};

/**
 * TimeStamp defines a timestamp
 */
export type TimeStamp = number;

/**
 * TimelineComment represents a timeline comment (comment of any type) on a commit or issue
 */
export type TimelineComment = {
    assignee?: User;
    assignee_team?: Team;
    body?: string;
    created_at?: string;
    dependent_issue?: Issue;
    html_url?: string;
    id?: number;
    issue_url?: string;
    label?: Label;
    milestone?: Milestone;
    new_ref?: string;
    new_title?: string;
    old_milestone?: Milestone;
    old_project_id?: number;
    old_ref?: string;
    old_title?: string;
    project_id?: number;
    pull_request_url?: string;
    ref_action?: string;
    ref_comment?: Comment;
    /**
     * commit SHA where issue/PR was referenced
     */
    ref_commit_sha?: string;
    ref_issue?: Issue;
    /**
     * whether the assignees were removed or added
     */
    removed_assignee?: boolean;
    resolve_doer?: User;
    review_id?: number;
    tracked_time?: TrackedTime;
    type?: string;
    updated_at?: string;
    user?: User;
};

/**
 * TopicName a list of repo topic names
 */
export type TopicName = {
    topics?: Array<string>;
};

/**
 * TopicResponse for returning topics
 */
export type TopicResponse = {
    created?: string;
    id?: number;
    repo_count?: number;
    topic_name?: string;
    updated?: string;
};

/**
 * TrackedTime worked time for an issue / pr
 */
export type TrackedTime = {
    created?: string;
    id?: number;
    issue?: Issue;
    /**
     * deprecated (only for backwards compatibility)
     */
    issue_id?: number;
    /**
     * Time in seconds
     */
    time?: number;
    /**
     * deprecated (only for backwards compatibility)
     */
    user_id?: number;
    user_name?: string;
};

/**
 * TransferRepoOption options when transfer a repository's ownership
 */
export type TransferRepoOption = {
    new_owner: string;
    /**
     * ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
     */
    team_ids?: Array<number>;
};

/**
 * UpdateBranchRepoOption options when updating a branch in a repository
 */
export type UpdateBranchRepoOption = {
    /**
     * New branch name
     */
    name: string;
};

/**
 * UpdateFileOptions options for updating files
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type UpdateFileOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    /**
     * content must be base64 encoded
     */
    content: string;
    dates?: CommitDateOptions;
    /**
     * from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL
     */
    from_path?: string;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * sha is the SHA for the file that already exists
     */
    sha: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * UpdateRepoAvatarUserOption options when updating the repo avatar
 */
export type UpdateRepoAvatarOption = {
    /**
     * image must be base64 encoded
     */
    image?: string;
};

/**
 * UpdateUserAvatarUserOption options when updating the user avatar
 */
export type UpdateUserAvatarOption = {
    /**
     * image must be base64 encoded
     */
    image?: string;
};

/**
 * UpdateVariableOption the option when updating variable
 */
export type UpdateVariableOption = {
    /**
     * New name for the variable. If the field is empty, the variable name won't be updated.
     */
    name?: string;
    /**
     * Value of the variable to update
     */
    value: string;
};

/**
 * User represents a user
 */
export type User = {
    /**
     * Is user active
     */
    active?: boolean;
    /**
     * URL to the user's avatar
     */
    avatar_url?: string;
    created?: string;
    /**
     * the user's description
     */
    description?: string;
    email?: string;
    /**
     * user counts
     */
    followers_count?: number;
    following_count?: number;
    /**
     * the user's full name
     */
    full_name?: string;
    /**
     * URL to the user's profile page
     */
    html_url?: string;
    /**
     * the user's id
     */
    id?: number;
    /**
     * Is the user an administrator
     */
    is_admin?: boolean;
    /**
     * User locale
     */
    language?: string;
    last_login?: string;
    /**
     * the user's location
     */
    location?: string;
    /**
     * the user's username
     */
    login?: string;
    /**
     * the user's authentication sign-in name.
     */
    login_name?: string;
    /**
     * Is user login prohibited
     */
    prohibit_login?: boolean;
    /**
     * the user's pronouns
     */
    pronouns?: string;
    /**
     * Is user restricted
     */
    restricted?: boolean;
    /**
     * The ID of the user's Authentication Source
     */
    source_id?: number;
    starred_repos_count?: number;
    /**
     * User visibility level option: public, limited, private
     */
    visibility?: string;
    /**
     * the user's website
     */
    website?: string;
};

/**
 * UserHeatmapData represents the data needed to create a heatmap
 */
export type UserHeatmapData = {
    contributions?: number;
    timestamp?: TimeStamp;
};

/**
 * UserSettings represents user settings
 */
export type UserSettings = {
    description?: string;
    diff_view_style?: string;
    enable_repo_unit_hints?: boolean;
    full_name?: string;
    hide_activity?: boolean;
    /**
     * Privacy
     */
    hide_email?: boolean;
    hide_pronouns?: boolean;
    language?: string;
    location?: string;
    pronouns?: string;
    theme?: string;
    website?: string;
};

/**
 * UserSettingsOptions represents options to change user settings
 */
export type UserSettingsOptions = {
    description?: string;
    diff_view_style?: string;
    enable_repo_unit_hints?: boolean;
    full_name?: string;
    hide_activity?: boolean;
    /**
     * Privacy
     */
    hide_email?: boolean;
    hide_pronouns?: boolean;
    language?: string;
    location?: string;
    pronouns?: string;
    theme?: string;
    website?: string;
};

/**
 * WatchInfo represents an API watch status of one repository
 */
export type WatchInfo = {
    created_at?: string;
    ignored?: boolean;
    reason?: unknown;
    repository_url?: string;
    subscribed?: boolean;
    url?: string;
};

/**
 * WikiCommit page commit/revision
 */
export type WikiCommit = {
    author?: CommitUser;
    commiter?: CommitUser;
    message?: string;
    sha?: string;
};

/**
 * WikiCommitList commit/revision list
 */
export type WikiCommitList = {
    commits?: Array<WikiCommit>;
    count?: number;
};

/**
 * WikiPage a wiki page
 */
export type WikiPage = {
    commit_count?: number;
    /**
     * Page content, base64 encoded
     */
    content_base64?: string;
    footer?: string;
    html_url?: string;
    last_commit?: WikiCommit;
    sidebar?: string;
    sub_url?: string;
    title?: string;
};

/**
 * WikiPageMetaData wiki page meta information
 */
export type WikiPageMetaData = {
    html_url?: string;
    last_commit?: WikiCommit;
    sub_url?: string;
    title?: string;
};

export type ActivitypubInstanceActorData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/activitypub/actor';
};

export type ActivitypubInstanceActorResponses = {
    /**
     * ActivityPub
     */
    200: ActivityPub;
};

export type ActivitypubInstanceActorResponse = ActivitypubInstanceActorResponses[keyof ActivitypubInstanceActorResponses];

export type ActivitypubInstanceActorInboxData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/activitypub/actor/inbox';
};

export type ActivitypubInstanceActorInboxResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type ActivitypubRepositoryData = {
    body?: never;
    path: {
        /**
         * repository ID of the repo
         */
        'repository-id': number;
    };
    query?: never;
    url: '/activitypub/repository-id/{repository-id}';
};

export type ActivitypubRepositoryResponses = {
    /**
     * ActivityPub
     */
    200: ActivityPub;
};

export type ActivitypubRepositoryResponse = ActivitypubRepositoryResponses[keyof ActivitypubRepositoryResponses];

export type ActivitypubRepositoryInboxData = {
    body?: ForgeLike;
    path: {
        /**
         * repository ID of the repo
         */
        'repository-id': number;
    };
    query?: never;
    url: '/activitypub/repository-id/{repository-id}/inbox';
};

export type ActivitypubRepositoryInboxResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type ActivitypubPersonData = {
    body?: never;
    path: {
        /**
         * user ID of the user
         */
        'user-id': number;
    };
    query?: never;
    url: '/activitypub/user-id/{user-id}';
};

export type ActivitypubPersonResponses = {
    /**
     * ActivityPub
     */
    200: ActivityPub;
};

export type ActivitypubPersonResponse = ActivitypubPersonResponses[keyof ActivitypubPersonResponses];

export type ActivitypubPersonInboxData = {
    body?: never;
    path: {
        /**
         * user ID of the user
         */
        'user-id': number;
    };
    query?: never;
    url: '/activitypub/user-id/{user-id}/inbox';
};

export type ActivitypubPersonInboxResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCronListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/cron';
};

export type AdminCronListErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminCronListError = AdminCronListErrors[keyof AdminCronListErrors];

export type AdminCronListResponses = {
    /**
     * CronList
     */
    200: Array<Cron>;
};

export type AdminCronListResponse = AdminCronListResponses[keyof AdminCronListResponses];

export type AdminCronRunData = {
    body?: never;
    path: {
        /**
         * task to run
         */
        task: string;
    };
    query?: never;
    url: '/admin/cron/{task}';
};

export type AdminCronRunErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminCronRunError = AdminCronRunErrors[keyof AdminCronRunErrors];

export type AdminCronRunResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminGetAllEmailsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/emails';
};

export type AdminGetAllEmailsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminGetAllEmailsError = AdminGetAllEmailsErrors[keyof AdminGetAllEmailsErrors];

export type AdminGetAllEmailsResponses = {
    /**
     * EmailList
     */
    200: Array<Email>;
};

export type AdminGetAllEmailsResponse = AdminGetAllEmailsResponses[keyof AdminGetAllEmailsResponses];

export type AdminSearchEmailsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * keyword
         */
        q?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/emails/search';
};

export type AdminSearchEmailsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminSearchEmailsError = AdminSearchEmailsErrors[keyof AdminSearchEmailsErrors];

export type AdminSearchEmailsResponses = {
    /**
     * EmailList
     */
    200: Array<Email>;
};

export type AdminSearchEmailsResponse = AdminSearchEmailsResponses[keyof AdminSearchEmailsResponses];

export type AdminListHooksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/hooks';
};

export type AdminListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type AdminListHooksResponse = AdminListHooksResponses[keyof AdminListHooksResponses];

export type AdminCreateHookData = {
    body: CreateHookOption;
    path?: never;
    query?: never;
    url: '/admin/hooks';
};

export type AdminCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type AdminCreateHookResponse = AdminCreateHookResponses[keyof AdminCreateHookResponses];

export type AdminDeleteHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/admin/hooks/{id}';
};

export type AdminDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminGetHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/admin/hooks/{id}';
};

export type AdminGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type AdminGetHookResponse = AdminGetHookResponses[keyof AdminGetHookResponses];

export type AdminEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * id of the hook to update
         */
        id: number;
    };
    query?: never;
    url: '/admin/hooks/{id}';
};

export type AdminEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type AdminEditHookResponse = AdminEditHookResponses[keyof AdminEditHookResponses];

export type AdminGetAllOrgsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/orgs';
};

export type AdminGetAllOrgsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminGetAllOrgsError = AdminGetAllOrgsErrors[keyof AdminGetAllOrgsErrors];

export type AdminGetAllOrgsResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type AdminGetAllOrgsResponse = AdminGetAllOrgsResponses[keyof AdminGetAllOrgsResponses];

export type AdminListQuotaGroupsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/admin/quota/groups';
};

export type AdminListQuotaGroupsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminListQuotaGroupsError = AdminListQuotaGroupsErrors[keyof AdminListQuotaGroupsErrors];

export type AdminListQuotaGroupsResponses = {
    /**
     * QuotaGroupList
     */
    200: QuotaGroupList;
};

export type AdminListQuotaGroupsResponse = AdminListQuotaGroupsResponses[keyof AdminListQuotaGroupsResponses];

export type AdminCreateQuotaGroupData = {
    /**
     * Definition of the quota group
     */
    body: CreateQuotaGroupOptions;
    path?: never;
    query?: never;
    url: '/admin/quota/groups';
};

export type AdminCreateQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminCreateQuotaGroupError = AdminCreateQuotaGroupErrors[keyof AdminCreateQuotaGroupErrors];

export type AdminCreateQuotaGroupResponses = {
    /**
     * QuotaGroup
     */
    201: QuotaGroup;
};

export type AdminCreateQuotaGroupResponse = AdminCreateQuotaGroupResponses[keyof AdminCreateQuotaGroupResponses];

export type AdminDeleteQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to delete
         */
        quotagroup: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}';
};

export type AdminDeleteQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminDeleteQuotaGroupError = AdminDeleteQuotaGroupErrors[keyof AdminDeleteQuotaGroupErrors];

export type AdminDeleteQuotaGroupResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminGetQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to query
         */
        quotagroup: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}';
};

export type AdminGetQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminGetQuotaGroupError = AdminGetQuotaGroupErrors[keyof AdminGetQuotaGroupErrors];

export type AdminGetQuotaGroupResponses = {
    /**
     * QuotaGroup
     */
    200: QuotaGroup;
};

export type AdminGetQuotaGroupResponse = AdminGetQuotaGroupResponses[keyof AdminGetQuotaGroupResponses];

export type AdminRemoveRuleFromQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to remove a rule from
         */
        quotagroup: string;
        /**
         * the name of the quota rule to remove from the group
         */
        quotarule: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}/rules/{quotarule}';
};

export type AdminRemoveRuleFromQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminRemoveRuleFromQuotaGroupError = AdminRemoveRuleFromQuotaGroupErrors[keyof AdminRemoveRuleFromQuotaGroupErrors];

export type AdminRemoveRuleFromQuotaGroupResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type AdminAddRuleToQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to add a rule to
         */
        quotagroup: string;
        /**
         * the name of the quota rule to add to the group
         */
        quotarule: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}/rules/{quotarule}';
};

export type AdminAddRuleToQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminAddRuleToQuotaGroupError = AdminAddRuleToQuotaGroupErrors[keyof AdminAddRuleToQuotaGroupErrors];

export type AdminAddRuleToQuotaGroupResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminListUsersInQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to list members of
         */
        quotagroup: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}/users';
};

export type AdminListUsersInQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminListUsersInQuotaGroupError = AdminListUsersInQuotaGroupErrors[keyof AdminListUsersInQuotaGroupErrors];

export type AdminListUsersInQuotaGroupResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type AdminListUsersInQuotaGroupResponse = AdminListUsersInQuotaGroupResponses[keyof AdminListUsersInQuotaGroupResponses];

export type AdminRemoveUserFromQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to remove a user from
         */
        quotagroup: string;
        /**
         * username of the user to remove from the quota group
         */
        username: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}/users/{username}';
};

export type AdminRemoveUserFromQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminRemoveUserFromQuotaGroupError = AdminRemoveUserFromQuotaGroupErrors[keyof AdminRemoveUserFromQuotaGroupErrors];

export type AdminRemoveUserFromQuotaGroupResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminAddUserToQuotaGroupData = {
    body?: never;
    path: {
        /**
         * quota group to add the user to
         */
        quotagroup: string;
        /**
         * username of the user to add to the quota group
         */
        username: string;
    };
    query?: never;
    url: '/admin/quota/groups/{quotagroup}/users/{username}';
};

export type AdminAddUserToQuotaGroupErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminAddUserToQuotaGroupError = AdminAddUserToQuotaGroupErrors[keyof AdminAddUserToQuotaGroupErrors];

export type AdminAddUserToQuotaGroupResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminListQuotaRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/admin/quota/rules';
};

export type AdminListQuotaRulesErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminListQuotaRulesError = AdminListQuotaRulesErrors[keyof AdminListQuotaRulesErrors];

export type AdminListQuotaRulesResponses = {
    /**
     * QuotaRuleInfoList
     */
    200: Array<QuotaRuleInfo>;
};

export type AdminListQuotaRulesResponse = AdminListQuotaRulesResponses[keyof AdminListQuotaRulesResponses];

export type AdminCreateQuotaRuleData = {
    /**
     * Definition of the quota rule
     */
    body: CreateQuotaRuleOptions;
    path?: never;
    query?: never;
    url: '/admin/quota/rules';
};

export type AdminCreateQuotaRuleErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminCreateQuotaRuleError = AdminCreateQuotaRuleErrors[keyof AdminCreateQuotaRuleErrors];

export type AdminCreateQuotaRuleResponses = {
    /**
     * QuotaRuleInfo
     */
    201: QuotaRuleInfo;
};

export type AdminCreateQuotaRuleResponse = AdminCreateQuotaRuleResponses[keyof AdminCreateQuotaRuleResponses];

export type AdminDEleteQuotaRuleData = {
    body?: never;
    path: {
        /**
         * quota rule to delete
         */
        quotarule: string;
    };
    query?: never;
    url: '/admin/quota/rules/{quotarule}';
};

export type AdminDEleteQuotaRuleErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminDEleteQuotaRuleError = AdminDEleteQuotaRuleErrors[keyof AdminDEleteQuotaRuleErrors];

export type AdminDEleteQuotaRuleResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminGetQuotaRuleData = {
    body?: never;
    path: {
        /**
         * quota rule to query
         */
        quotarule: string;
    };
    query?: never;
    url: '/admin/quota/rules/{quotarule}';
};

export type AdminGetQuotaRuleErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminGetQuotaRuleError = AdminGetQuotaRuleErrors[keyof AdminGetQuotaRuleErrors];

export type AdminGetQuotaRuleResponses = {
    /**
     * QuotaRuleInfo
     */
    200: QuotaRuleInfo;
};

export type AdminGetQuotaRuleResponse = AdminGetQuotaRuleResponses[keyof AdminGetQuotaRuleResponses];

export type AdminEditQuotaRuleData = {
    body: EditQuotaRuleOptions;
    path: {
        /**
         * Quota rule to change
         */
        quotarule: string;
    };
    query?: never;
    url: '/admin/quota/rules/{quotarule}';
};

export type AdminEditQuotaRuleErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminEditQuotaRuleError = AdminEditQuotaRuleErrors[keyof AdminEditQuotaRuleErrors];

export type AdminEditQuotaRuleResponses = {
    /**
     * QuotaRuleInfo
     */
    200: QuotaRuleInfo;
};

export type AdminEditQuotaRuleResponse = AdminEditQuotaRuleResponses[keyof AdminEditQuotaRuleResponses];

export type AdminSearchRunJobsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * a comma separated list of run job labels to search for
         */
        labels?: string;
    };
    url: '/admin/runners/jobs';
};

export type AdminSearchRunJobsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminSearchRunJobsError = AdminSearchRunJobsErrors[keyof AdminSearchRunJobsErrors];

export type AdminSearchRunJobsResponses = {
    /**
     * RunJobList is a list of action run jobs
     */
    200: Array<ActionRunJob>;
};

export type AdminSearchRunJobsResponse = AdminSearchRunJobsResponses[keyof AdminSearchRunJobsResponses];

export type AdminGetRunnerRegistrationTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/admin/runners/registration-token';
};

export type AdminGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is a string used to register a runner with a server
     */
    200: unknown;
};

export type AdminUnadoptedListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * pattern of repositories to search for
         */
        pattern?: string;
    };
    url: '/admin/unadopted';
};

export type AdminUnadoptedListErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminUnadoptedListError = AdminUnadoptedListErrors[keyof AdminUnadoptedListErrors];

export type AdminUnadoptedListResponses = {
    /**
     * StringSlice
     */
    200: Array<string>;
};

export type AdminUnadoptedListResponse = AdminUnadoptedListResponses[keyof AdminUnadoptedListResponses];

export type AdminDeleteUnadoptedRepositoryData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/admin/unadopted/{owner}/{repo}';
};

export type AdminDeleteUnadoptedRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminDeleteUnadoptedRepositoryError = AdminDeleteUnadoptedRepositoryErrors[keyof AdminDeleteUnadoptedRepositoryErrors];

export type AdminDeleteUnadoptedRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminAdoptRepositoryData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/admin/unadopted/{owner}/{repo}';
};

export type AdminAdoptRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminAdoptRepositoryError = AdminAdoptRepositoryErrors[keyof AdminAdoptRepositoryErrors];

export type AdminAdoptRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminSearchUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ID of the user's login source to search for
         */
        source_id?: number;
        /**
         * user's login name to search for
         */
        login_name?: string;
        /**
         * sort order of results
         */
        sort?: 'oldest' | 'newest' | 'alphabetically' | 'reversealphabetically' | 'recentupdate' | 'leastupdate';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/users';
};

export type AdminSearchUsersErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type AdminSearchUsersError = AdminSearchUsersErrors[keyof AdminSearchUsersErrors];

export type AdminSearchUsersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type AdminSearchUsersResponse = AdminSearchUsersResponses[keyof AdminSearchUsersResponses];

export type AdminCreateUserData = {
    body?: CreateUserOption;
    path?: never;
    query?: never;
    url: '/admin/users';
};

export type AdminCreateUserErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminCreateUserError = AdminCreateUserErrors[keyof AdminCreateUserErrors];

export type AdminCreateUserResponses = {
    /**
     * User
     */
    201: User;
};

export type AdminCreateUserResponse = AdminCreateUserResponses[keyof AdminCreateUserResponses];

export type AdminDeleteUserData = {
    body?: never;
    path: {
        /**
         * username of user to delete
         */
        username: string;
    };
    query?: {
        /**
         * purge the user from the system completely
         */
        purge?: boolean;
    };
    url: '/admin/users/{username}';
};

export type AdminDeleteUserErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminDeleteUserError = AdminDeleteUserErrors[keyof AdminDeleteUserErrors];

export type AdminDeleteUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminEditUserData = {
    body?: EditUserOption;
    path: {
        /**
         * username of user to edit
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}';
};

export type AdminEditUserErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminEditUserError = AdminEditUserErrors[keyof AdminEditUserErrors];

export type AdminEditUserResponses = {
    /**
     * User
     */
    200: User;
};

export type AdminEditUserResponse = AdminEditUserResponses[keyof AdminEditUserResponses];

export type AdminCreatePublicKeyData = {
    body?: CreateKeyOption;
    path: {
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/keys';
};

export type AdminCreatePublicKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminCreatePublicKeyError = AdminCreatePublicKeyErrors[keyof AdminCreatePublicKeyErrors];

export type AdminCreatePublicKeyResponses = {
    /**
     * PublicKey
     */
    201: PublicKey;
};

export type AdminCreatePublicKeyResponse = AdminCreatePublicKeyResponses[keyof AdminCreatePublicKeyResponses];

export type AdminDeleteUserPublicKeyData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
        /**
         * id of the key to delete
         */
        id: number;
    };
    query?: never;
    url: '/admin/users/{username}/keys/{id}';
};

export type AdminDeleteUserPublicKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type AdminDeleteUserPublicKeyError = AdminDeleteUserPublicKeyErrors[keyof AdminDeleteUserPublicKeyErrors];

export type AdminDeleteUserPublicKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCreateOrgData = {
    body: CreateOrgOption;
    path: {
        /**
         * username of the user that will own the created organization
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/orgs';
};

export type AdminCreateOrgErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminCreateOrgError = AdminCreateOrgErrors[keyof AdminCreateOrgErrors];

export type AdminCreateOrgResponses = {
    /**
     * Organization
     */
    201: Organization;
};

export type AdminCreateOrgResponse = AdminCreateOrgResponses[keyof AdminCreateOrgResponses];

export type AdminGetUserQuotaData = {
    body?: never;
    path: {
        /**
         * username of user to query
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/quota';
};

export type AdminGetUserQuotaErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminGetUserQuotaError = AdminGetUserQuotaErrors[keyof AdminGetUserQuotaErrors];

export type AdminGetUserQuotaResponses = {
    /**
     * QuotaInfo
     */
    200: QuotaInfo;
};

export type AdminGetUserQuotaResponse = AdminGetUserQuotaResponses[keyof AdminGetUserQuotaResponses];

export type AdminSetUserQuotaGroupsData = {
    /**
     * list of groups that the user should be a member of
     */
    body: SetUserQuotaGroupsOptions;
    path: {
        /**
         * username of the user to modify the quota groups from
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/quota/groups';
};

export type AdminSetUserQuotaGroupsErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminSetUserQuotaGroupsError = AdminSetUserQuotaGroupsErrors[keyof AdminSetUserQuotaGroupsErrors];

export type AdminSetUserQuotaGroupsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminRenameUserData = {
    body: RenameUserOption;
    path: {
        /**
         * existing username of user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/rename';
};

export type AdminRenameUserErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminRenameUserError = AdminRenameUserErrors[keyof AdminRenameUserErrors];

export type AdminRenameUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCreateRepoData = {
    body: CreateRepoOption;
    path: {
        /**
         * username of the user. This user will own the created repository
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/repos';
};

export type AdminCreateRepoErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type AdminCreateRepoError = AdminCreateRepoErrors[keyof AdminCreateRepoErrors];

export type AdminCreateRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type AdminCreateRepoResponse = AdminCreateRepoResponses[keyof AdminCreateRepoResponses];

export type ListGitignoresTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/gitignore/templates';
};

export type ListGitignoresTemplatesResponses = {
    /**
     * GitignoreTemplateList
     */
    200: Array<string>;
};

export type ListGitignoresTemplatesResponse = ListGitignoresTemplatesResponses[keyof ListGitignoresTemplatesResponses];

export type GetGitignoreTemplateInfoData = {
    body?: never;
    path: {
        /**
         * name of the template
         */
        name: string;
    };
    query?: never;
    url: '/gitignore/templates/{name}';
};

export type GetGitignoreTemplateInfoErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetGitignoreTemplateInfoError = GetGitignoreTemplateInfoErrors[keyof GetGitignoreTemplateInfoErrors];

export type GetGitignoreTemplateInfoResponses = {
    /**
     * GitignoreTemplateInfo
     */
    200: GitignoreTemplateInfo;
};

export type GetGitignoreTemplateInfoResponse = GetGitignoreTemplateInfoResponses[keyof GetGitignoreTemplateInfoResponses];

export type ListLabelTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/label/templates';
};

export type ListLabelTemplatesResponses = {
    /**
     * LabelTemplateList
     */
    200: Array<string>;
};

export type ListLabelTemplatesResponse = ListLabelTemplatesResponses[keyof ListLabelTemplatesResponses];

export type GetLabelTemplateInfoData = {
    body?: never;
    path: {
        /**
         * name of the template
         */
        name: string;
    };
    query?: never;
    url: '/label/templates/{name}';
};

export type GetLabelTemplateInfoErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetLabelTemplateInfoError = GetLabelTemplateInfoErrors[keyof GetLabelTemplateInfoErrors];

export type GetLabelTemplateInfoResponses = {
    /**
     * LabelTemplateInfo
     */
    200: Array<LabelTemplate>;
};

export type GetLabelTemplateInfoResponse = GetLabelTemplateInfoResponses[keyof GetLabelTemplateInfoResponses];

export type ListLicenseTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/licenses';
};

export type ListLicenseTemplatesResponses = {
    /**
     * LicenseTemplateList
     */
    200: Array<LicensesTemplateListEntry>;
};

export type ListLicenseTemplatesResponse = ListLicenseTemplatesResponses[keyof ListLicenseTemplatesResponses];

export type GetLicenseTemplateInfoData = {
    body?: never;
    path: {
        /**
         * name of the license
         */
        name: string;
    };
    query?: never;
    url: '/licenses/{name}';
};

export type GetLicenseTemplateInfoErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetLicenseTemplateInfoError = GetLicenseTemplateInfoErrors[keyof GetLicenseTemplateInfoErrors];

export type GetLicenseTemplateInfoResponses = {
    /**
     * LicenseTemplateInfo
     */
    200: LicenseTemplateInfo;
};

export type GetLicenseTemplateInfoResponse = GetLicenseTemplateInfoResponses[keyof GetLicenseTemplateInfoResponses];

export type RenderMarkdownData = {
    body?: MarkdownOption;
    path?: never;
    query?: never;
    url: '/markdown';
};

export type RenderMarkdownErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RenderMarkdownError = RenderMarkdownErrors[keyof RenderMarkdownErrors];

export type RenderMarkdownResponses = {
    /**
     * MarkdownRender is a rendered markdown document
     */
    200: string;
};

export type RenderMarkdownResponse = RenderMarkdownResponses[keyof RenderMarkdownResponses];

export type RenderMarkdownRawData = {
    /**
     * Request body to render
     */
    body: string;
    path?: never;
    query?: never;
    url: '/markdown/raw';
};

export type RenderMarkdownRawErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RenderMarkdownRawError = RenderMarkdownRawErrors[keyof RenderMarkdownRawErrors];

export type RenderMarkdownRawResponses = {
    /**
     * MarkdownRender is a rendered markdown document
     */
    200: string;
};

export type RenderMarkdownRawResponse = RenderMarkdownRawResponses[keyof RenderMarkdownRawResponses];

export type RenderMarkupData = {
    body?: MarkupOption;
    path?: never;
    query?: never;
    url: '/markup';
};

export type RenderMarkupErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RenderMarkupError = RenderMarkupErrors[keyof RenderMarkupErrors];

export type RenderMarkupResponses = {
    /**
     * MarkupRender is a rendered markup document
     */
    200: string;
};

export type RenderMarkupResponse = RenderMarkupResponses[keyof RenderMarkupResponses];

export type GetNodeInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/nodeinfo';
};

export type GetNodeInfoResponses = {
    /**
     * NodeInfo
     */
    200: NodeInfo;
};

export type GetNodeInfoResponse = GetNodeInfoResponses[keyof GetNodeInfoResponses];

export type NotifyGetListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * If true, show notifications marked as read. Default value is false
         */
        all?: boolean;
        /**
         * Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned.
         */
        'status-types'?: Array<string>;
        /**
         * filter notifications by subject type
         */
        'subject-type'?: Array<'issue' | 'pull' | 'commit' | 'repository'>;
        /**
         * Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/notifications';
};

export type NotifyGetListResponses = {
    /**
     * NotificationThreadList
     */
    200: Array<NotificationThread>;
};

export type NotifyGetListResponse = NotifyGetListResponses[keyof NotifyGetListResponses];

export type NotifyReadListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         */
        last_read_at?: string;
        /**
         * If true, mark all notifications on this repo. Default value is false
         */
        all?: string;
        /**
         * Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         */
        'status-types'?: Array<string>;
        /**
         * Status to mark notifications as, Defaults to read.
         */
        'to-status'?: string;
    };
    url: '/notifications';
};

export type NotifyReadListResponses = {
    /**
     * NotificationThreadList
     */
    205: Array<NotificationThread>;
};

export type NotifyReadListResponse = NotifyReadListResponses[keyof NotifyReadListResponses];

export type NotifyNewAvailableData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/notifications/new';
};

export type NotifyNewAvailableResponses = {
    /**
     * Number of unread notifications
     */
    200: NotificationCount;
};

export type NotifyNewAvailableResponse = NotifyNewAvailableResponses[keyof NotifyNewAvailableResponses];

export type NotifyGetThreadData = {
    body?: never;
    path: {
        /**
         * id of notification thread
         */
        id: string;
    };
    query?: never;
    url: '/notifications/threads/{id}';
};

export type NotifyGetThreadErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type NotifyGetThreadError = NotifyGetThreadErrors[keyof NotifyGetThreadErrors];

export type NotifyGetThreadResponses = {
    /**
     * NotificationThread
     */
    200: NotificationThread;
};

export type NotifyGetThreadResponse = NotifyGetThreadResponses[keyof NotifyGetThreadResponses];

export type NotifyReadThreadData = {
    body?: never;
    path: {
        /**
         * id of notification thread
         */
        id: string;
    };
    query?: {
        /**
         * Status to mark notifications as
         */
        'to-status'?: string;
    };
    url: '/notifications/threads/{id}';
};

export type NotifyReadThreadErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type NotifyReadThreadError = NotifyReadThreadErrors[keyof NotifyReadThreadErrors];

export type NotifyReadThreadResponses = {
    /**
     * NotificationThread
     */
    205: NotificationThread;
};

export type NotifyReadThreadResponse = NotifyReadThreadResponses[keyof NotifyReadThreadResponses];

export type CreateOrgRepoDeprecatedData = {
    body?: CreateRepoOption;
    path: {
        /**
         * name of organization
         */
        org: string;
    };
    query?: never;
    url: '/org/{org}/repos';
};

export type CreateOrgRepoDeprecatedErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type CreateOrgRepoDeprecatedError = CreateOrgRepoDeprecatedErrors[keyof CreateOrgRepoDeprecatedErrors];

export type CreateOrgRepoDeprecatedResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type CreateOrgRepoDeprecatedResponse = CreateOrgRepoDeprecatedResponses[keyof CreateOrgRepoDeprecatedResponses];

export type OrgGetAllData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs';
};

export type OrgGetAllResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type OrgGetAllResponse = OrgGetAllResponses[keyof OrgGetAllResponses];

export type OrgCreateData = {
    body: CreateOrgOption;
    path?: never;
    query?: never;
    url: '/orgs';
};

export type OrgCreateErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgCreateError = OrgCreateErrors[keyof OrgCreateErrors];

export type OrgCreateResponses = {
    /**
     * Organization
     */
    201: Organization;
};

export type OrgCreateResponse = OrgCreateResponses[keyof OrgCreateResponses];

export type OrgDeleteData = {
    body?: never;
    path: {
        /**
         * organization that is to be deleted
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}';
};

export type OrgDeleteErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgDeleteError = OrgDeleteErrors[keyof OrgDeleteErrors];

export type OrgDeleteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgGetData = {
    body?: never;
    path: {
        /**
         * name of the organization to get
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}';
};

export type OrgGetErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgGetError = OrgGetErrors[keyof OrgGetErrors];

export type OrgGetResponses = {
    /**
     * Organization
     */
    200: Organization;
};

export type OrgGetResponse = OrgGetResponses[keyof OrgGetResponses];

export type OrgEditData = {
    body: EditOrgOption;
    path: {
        /**
         * name of the organization to edit
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}';
};

export type OrgEditErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    422: ApiError;
};

export type OrgEditError = OrgEditErrors[keyof OrgEditErrors];

export type OrgEditResponses = {
    /**
     * Organization
     */
    200: Organization;
};

export type OrgEditResponse = OrgEditResponses[keyof OrgEditResponses];

export type OrgSearchRunJobsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * a comma separated list of run job labels to search for
         */
        labels?: string;
    };
    url: '/orgs/{org}/actions/runners/jobs';
};

export type OrgSearchRunJobsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type OrgSearchRunJobsError = OrgSearchRunJobsErrors[keyof OrgSearchRunJobsErrors];

export type OrgSearchRunJobsResponses = {
    /**
     * RunJobList is a list of action run jobs
     */
    200: Array<ActionRunJob>;
};

export type OrgSearchRunJobsResponse = OrgSearchRunJobsResponses[keyof OrgSearchRunJobsResponses];

export type OrgGetRunnerRegistrationTokenData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/runners/registration-token';
};

export type OrgGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is a string used to register a runner with a server
     */
    200: unknown;
};

export type OrgListActionsSecretsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/actions/secrets';
};

export type OrgListActionsSecretsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListActionsSecretsError = OrgListActionsSecretsErrors[keyof OrgListActionsSecretsErrors];

export type OrgListActionsSecretsResponses = {
    /**
     * SecretList
     */
    200: Array<Secret>;
};

export type OrgListActionsSecretsResponse = OrgListActionsSecretsResponses[keyof OrgListActionsSecretsResponses];

export type DeleteOrgSecretData = {
    body?: never;
    path: {
        /**
         * name of organization
         */
        org: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/secrets/{secretname}';
};

export type DeleteOrgSecretErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeleteOrgSecretError = DeleteOrgSecretErrors[keyof DeleteOrgSecretErrors];

export type DeleteOrgSecretResponses = {
    /**
     * delete one secret of the organization
     */
    204: unknown;
};

export type UpdateOrgSecretData = {
    body?: CreateOrUpdateSecretOption;
    path: {
        /**
         * name of organization
         */
        org: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/secrets/{secretname}';
};

export type UpdateOrgSecretErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UpdateOrgSecretError = UpdateOrgSecretErrors[keyof UpdateOrgSecretErrors];

export type UpdateOrgSecretResponses = {
    /**
     * response when creating a secret
     */
    201: unknown;
    /**
     * response when updating a secret
     */
    204: unknown;
};

export type GetOrgVariablesListData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/actions/variables';
};

export type GetOrgVariablesListErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetOrgVariablesListError = GetOrgVariablesListErrors[keyof GetOrgVariablesListErrors];

export type GetOrgVariablesListResponses = {
    /**
     * VariableList
     */
    200: Array<ActionVariable>;
};

export type GetOrgVariablesListResponse = GetOrgVariablesListResponses[keyof GetOrgVariablesListResponses];

export type DeleteOrgVariableData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type DeleteOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeleteOrgVariableError = DeleteOrgVariableErrors[keyof DeleteOrgVariableErrors];

export type DeleteOrgVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
    /**
     * response when deleting a variable
     */
    201: unknown;
    /**
     * response when deleting a variable
     */
    204: unknown;
};

export type DeleteOrgVariableResponse = DeleteOrgVariableResponses[keyof DeleteOrgVariableResponses];

export type GetOrgVariableData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type GetOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetOrgVariableError = GetOrgVariableErrors[keyof GetOrgVariableErrors];

export type GetOrgVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
};

export type GetOrgVariableResponse = GetOrgVariableResponses[keyof GetOrgVariableResponses];

export type CreateOrgVariableData = {
    body?: CreateVariableOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type CreateOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type CreateOrgVariableError = CreateOrgVariableErrors[keyof CreateOrgVariableErrors];

export type CreateOrgVariableResponses = {
    /**
     * response when creating an org-level variable
     */
    201: unknown;
    /**
     * response when creating an org-level variable
     */
    204: unknown;
};

export type UpdateOrgVariableData = {
    body?: UpdateVariableOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type UpdateOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UpdateOrgVariableError = UpdateOrgVariableErrors[keyof UpdateOrgVariableErrors];

export type UpdateOrgVariableResponses = {
    /**
     * response when updating an org-level variable
     */
    201: unknown;
    /**
     * response when updating an org-level variable
     */
    204: unknown;
};

export type OrgListActivityFeedsData = {
    body?: never;
    path: {
        /**
         * name of the org
         */
        org: string;
    };
    query?: {
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/activities/feeds';
};

export type OrgListActivityFeedsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListActivityFeedsError = OrgListActivityFeedsErrors[keyof OrgListActivityFeedsErrors];

export type OrgListActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type OrgListActivityFeedsResponse = OrgListActivityFeedsResponses[keyof OrgListActivityFeedsResponses];

export type OrgDeleteAvatarData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/avatar';
};

export type OrgDeleteAvatarErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgDeleteAvatarError = OrgDeleteAvatarErrors[keyof OrgDeleteAvatarErrors];

export type OrgDeleteAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgUpdateAvatarData = {
    body?: UpdateUserAvatarOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/avatar';
};

export type OrgUpdateAvatarErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgUpdateAvatarError = OrgUpdateAvatarErrors[keyof OrgUpdateAvatarErrors];

export type OrgUpdateAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgBlockUserData = {
    body?: never;
    path: {
        /**
         * name of the org
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/block/{username}';
};

export type OrgBlockUserErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgBlockUserError = OrgBlockUserErrors[keyof OrgBlockUserErrors];

export type OrgBlockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListHooksData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/hooks';
};

export type OrgListHooksErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListHooksError = OrgListHooksErrors[keyof OrgListHooksErrors];

export type OrgListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type OrgListHooksResponse = OrgListHooksResponses[keyof OrgListHooksResponses];

export type OrgCreateHookData = {
    body: CreateHookOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/hooks';
};

export type OrgCreateHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgCreateHookError = OrgCreateHookErrors[keyof OrgCreateHookErrors];

export type OrgCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type OrgCreateHookResponse = OrgCreateHookResponses[keyof OrgCreateHookResponses];

export type OrgDeleteHookData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/hooks/{id}';
};

export type OrgDeleteHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgDeleteHookError = OrgDeleteHookErrors[keyof OrgDeleteHookErrors];

export type OrgDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgGetHookData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/hooks/{id}';
};

export type OrgGetHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgGetHookError = OrgGetHookErrors[keyof OrgGetHookErrors];

export type OrgGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type OrgGetHookResponse = OrgGetHookResponses[keyof OrgGetHookResponses];

export type OrgEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the hook to update
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/hooks/{id}';
};

export type OrgEditHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgEditHookError = OrgEditHookErrors[keyof OrgEditHookErrors];

export type OrgEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type OrgEditHookResponse = OrgEditHookResponses[keyof OrgEditHookResponses];

export type OrgListLabelsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/labels';
};

export type OrgListLabelsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListLabelsError = OrgListLabelsErrors[keyof OrgListLabelsErrors];

export type OrgListLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type OrgListLabelsResponse = OrgListLabelsResponses[keyof OrgListLabelsResponses];

export type OrgCreateLabelData = {
    body?: CreateLabelOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/labels';
};

export type OrgCreateLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgCreateLabelError = OrgCreateLabelErrors[keyof OrgCreateLabelErrors];

export type OrgCreateLabelResponses = {
    /**
     * Label
     */
    201: Label;
};

export type OrgCreateLabelResponse = OrgCreateLabelResponses[keyof OrgCreateLabelResponses];

export type OrgDeleteLabelData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the label to delete
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/labels/{id}';
};

export type OrgDeleteLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgDeleteLabelError = OrgDeleteLabelErrors[keyof OrgDeleteLabelErrors];

export type OrgDeleteLabelResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgGetLabelData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the label to get
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/labels/{id}';
};

export type OrgGetLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgGetLabelError = OrgGetLabelErrors[keyof OrgGetLabelErrors];

export type OrgGetLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type OrgGetLabelResponse = OrgGetLabelResponses[keyof OrgGetLabelResponses];

export type OrgEditLabelData = {
    body?: EditLabelOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the label to edit
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/labels/{id}';
};

export type OrgEditLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgEditLabelError = OrgEditLabelErrors[keyof OrgEditLabelErrors];

export type OrgEditLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type OrgEditLabelResponse = OrgEditLabelResponses[keyof OrgEditLabelResponses];

export type OrgListBlockedUsersData = {
    body?: never;
    path: {
        /**
         * name of the org
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/list_blocked';
};

export type OrgListBlockedUsersResponses = {
    /**
     * BlockedUserList
     */
    200: Array<BlockedUser>;
};

export type OrgListBlockedUsersResponse = OrgListBlockedUsersResponses[keyof OrgListBlockedUsersResponses];

export type OrgListMembersData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/members';
};

export type OrgListMembersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListMembersError = OrgListMembersErrors[keyof OrgListMembersErrors];

export type OrgListMembersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrgListMembersResponse = OrgListMembersResponses[keyof OrgListMembersResponses];

export type OrgDeleteMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/members/{username}';
};

export type OrgDeleteMemberErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgDeleteMemberError = OrgDeleteMemberErrors[keyof OrgDeleteMemberErrors];

export type OrgDeleteMemberResponses = {
    /**
     * member removed
     */
    204: unknown;
};

export type OrgIsMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/members/{username}';
};

export type OrgIsMemberErrors = {
    /**
     * user is not a member
     */
    404: unknown;
};

export type OrgIsMemberResponses = {
    /**
     * user is a member
     */
    204: unknown;
};

export type OrgListPublicMembersData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/public_members';
};

export type OrgListPublicMembersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListPublicMembersError = OrgListPublicMembersErrors[keyof OrgListPublicMembersErrors];

export type OrgListPublicMembersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrgListPublicMembersResponse = OrgListPublicMembersResponses[keyof OrgListPublicMembersResponses];

export type OrgConcealMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/public_members/{username}';
};

export type OrgConcealMemberErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgConcealMemberError = OrgConcealMemberErrors[keyof OrgConcealMemberErrors];

export type OrgConcealMemberResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgIsPublicMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/public_members/{username}';
};

export type OrgIsPublicMemberErrors = {
    /**
     * user is not a public member
     */
    404: unknown;
};

export type OrgIsPublicMemberResponses = {
    /**
     * user is a public member
     */
    204: unknown;
};

export type OrgPublicizeMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/public_members/{username}';
};

export type OrgPublicizeMemberErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgPublicizeMemberError = OrgPublicizeMemberErrors[keyof OrgPublicizeMemberErrors];

export type OrgPublicizeMemberResponses = {
    /**
     * membership publicized
     */
    204: unknown;
};

export type OrgGetQuotaData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/quota';
};

export type OrgGetQuotaErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgGetQuotaError = OrgGetQuotaErrors[keyof OrgGetQuotaErrors];

export type OrgGetQuotaResponses = {
    /**
     * QuotaInfo
     */
    200: QuotaInfo;
};

export type OrgGetQuotaResponse = OrgGetQuotaResponses[keyof OrgGetQuotaResponses];

export type OrgListQuotaArtifactsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/quota/artifacts';
};

export type OrgListQuotaArtifactsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListQuotaArtifactsError = OrgListQuotaArtifactsErrors[keyof OrgListQuotaArtifactsErrors];

export type OrgListQuotaArtifactsResponses = {
    /**
     * QuotaUsedArtifactList
     */
    200: QuotaUsedArtifactList;
};

export type OrgListQuotaArtifactsResponse = OrgListQuotaArtifactsResponses[keyof OrgListQuotaArtifactsResponses];

export type OrgListQuotaAttachmentsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/quota/attachments';
};

export type OrgListQuotaAttachmentsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListQuotaAttachmentsError = OrgListQuotaAttachmentsErrors[keyof OrgListQuotaAttachmentsErrors];

export type OrgListQuotaAttachmentsResponses = {
    /**
     * QuotaUsedAttachmentList
     */
    200: QuotaUsedAttachmentList;
};

export type OrgListQuotaAttachmentsResponse = OrgListQuotaAttachmentsResponses[keyof OrgListQuotaAttachmentsResponses];

export type OrgCheckQuotaData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/quota/check';
};

export type OrgCheckQuotaErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgCheckQuotaError = OrgCheckQuotaErrors[keyof OrgCheckQuotaErrors];

export type OrgCheckQuotaResponses = {
    /**
     * Boolean
     */
    200: unknown;
};

export type OrgListQuotaPackagesData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/quota/packages';
};

export type OrgListQuotaPackagesErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListQuotaPackagesError = OrgListQuotaPackagesErrors[keyof OrgListQuotaPackagesErrors];

export type OrgListQuotaPackagesResponses = {
    /**
     * QuotaUsedPackageList
     */
    200: QuotaUsedPackageList;
};

export type OrgListQuotaPackagesResponse = OrgListQuotaPackagesResponses[keyof OrgListQuotaPackagesResponses];

export type RenameOrgData = {
    body: RenameOrgOption;
    path: {
        /**
         * existing org name
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/rename';
};

export type RenameOrgErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RenameOrgError = RenameOrgErrors[keyof RenameOrgErrors];

export type RenameOrgResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListReposData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/repos';
};

export type OrgListReposErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListReposError = OrgListReposErrors[keyof OrgListReposErrors];

export type OrgListReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type OrgListReposResponse = OrgListReposResponses[keyof OrgListReposResponses];

export type CreateOrgRepoData = {
    body?: CreateRepoOption;
    path: {
        /**
         * name of organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/repos';
};

export type CreateOrgRepoErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type CreateOrgRepoError = CreateOrgRepoErrors[keyof CreateOrgRepoErrors];

export type CreateOrgRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type CreateOrgRepoResponse = CreateOrgRepoResponses[keyof CreateOrgRepoResponses];

export type OrgListTeamsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/teams';
};

export type OrgListTeamsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListTeamsError = OrgListTeamsErrors[keyof OrgListTeamsErrors];

export type OrgListTeamsResponses = {
    /**
     * TeamList
     */
    200: Array<Team>;
};

export type OrgListTeamsResponse = OrgListTeamsResponses[keyof OrgListTeamsResponses];

export type OrgCreateTeamData = {
    body?: CreateTeamOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/teams';
};

export type OrgCreateTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgCreateTeamError = OrgCreateTeamErrors[keyof OrgCreateTeamErrors];

export type OrgCreateTeamResponses = {
    /**
     * Team
     */
    201: Team;
};

export type OrgCreateTeamResponse = OrgCreateTeamResponses[keyof OrgCreateTeamResponses];

export type TeamSearchData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * keywords to search
         */
        q?: string;
        /**
         * include search within team description (defaults to true)
         */
        include_desc?: boolean;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/teams/search';
};

export type TeamSearchErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type TeamSearchError = TeamSearchErrors[keyof TeamSearchErrors];

export type TeamSearchResponses = {
    /**
     * SearchResults of a successful search
     */
    200: {
        data?: Array<Team>;
        ok?: boolean;
    };
};

export type TeamSearchResponse = TeamSearchResponses[keyof TeamSearchResponses];

export type OrgUnblockUserData = {
    body?: never;
    path: {
        /**
         * name of the org
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/unblock/{username}';
};

export type OrgUnblockUserErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type OrgUnblockUserError = OrgUnblockUserErrors[keyof OrgUnblockUserErrors];

export type OrgUnblockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type ListPackagesData = {
    body?: never;
    path: {
        /**
         * owner of the packages
         */
        owner: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * package type filter
         */
        type?: 'alpine' | 'cargo' | 'chef' | 'composer' | 'conan' | 'conda' | 'container' | 'cran' | 'debian' | 'generic' | 'go' | 'helm' | 'maven' | 'npm' | 'nuget' | 'pub' | 'pypi' | 'rpm' | 'rubygems' | 'swift' | 'vagrant';
        /**
         * name filter
         */
        q?: string;
    };
    url: '/packages/{owner}';
};

export type ListPackagesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type ListPackagesError = ListPackagesErrors[keyof ListPackagesErrors];

export type ListPackagesResponses = {
    /**
     * PackageList
     */
    200: Array<Package>;
};

export type ListPackagesResponse = ListPackagesResponses[keyof ListPackagesResponses];

export type LinkPackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * name of the repository to link.
         */
        repo_name: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/-/link/{repo_name}';
};

export type LinkPackageErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type LinkPackageError = LinkPackageErrors[keyof LinkPackageErrors];

export type LinkPackageResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type UnlinkPackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/-/unlink';
};

export type UnlinkPackageErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UnlinkPackageError = UnlinkPackageErrors[keyof UnlinkPackageErrors];

export type UnlinkPackageResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type DeletePackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * version of the package
         */
        version: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/{version}';
};

export type DeletePackageErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeletePackageError = DeletePackageErrors[keyof DeletePackageErrors];

export type DeletePackageResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type GetPackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * version of the package
         */
        version: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/{version}';
};

export type GetPackageErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetPackageError = GetPackageErrors[keyof GetPackageErrors];

export type GetPackageResponses = {
    /**
     * Package
     */
    200: Package;
};

export type GetPackageResponse = GetPackageResponses[keyof GetPackageResponses];

export type ListPackageFilesData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * version of the package
         */
        version: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/{version}/files';
};

export type ListPackageFilesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type ListPackageFilesError = ListPackageFilesErrors[keyof ListPackageFilesErrors];

export type ListPackageFilesResponses = {
    /**
     * PackageFileList
     */
    200: Array<PackageFile>;
};

export type ListPackageFilesResponse = ListPackageFilesResponses[keyof ListPackageFilesResponses];

export type IssueSearchIssuesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * State of the issue
         */
        state?: 'open' | 'closed' | 'all';
        /**
         * Comma-separated list of label names. Fetch only issues that have any of these labels. Non existent labels are discarded.
         */
        labels?: string;
        /**
         * Comma-separated list of milestone names. Fetch only issues that have any of these milestones. Non existent milestones are discarded.
         */
        milestones?: string;
        /**
         * Search string
         */
        q?: string;
        /**
         * Repository ID to prioritize in the results
         */
        priority_repo_id?: number;
        /**
         * Filter by issue type
         */
        type?: 'issues' | 'pulls';
        /**
         * Only show issues updated after the given time (RFC 3339 format)
         */
        since?: string;
        /**
         * Only show issues updated before the given time (RFC 3339 format)
         */
        before?: string;
        /**
         * Filter issues or pulls assigned to the authenticated user
         */
        assigned?: boolean;
        /**
         * Filter issues or pulls created by the authenticated user
         */
        created?: boolean;
        /**
         * Filter issues or pulls mentioning the authenticated user
         */
        mentioned?: boolean;
        /**
         * Filter pull requests where the authenticated user's review was requested
         */
        review_requested?: boolean;
        /**
         * Filter pull requests reviewed by the authenticated user
         */
        reviewed?: boolean;
        /**
         * Filter by repository owner
         */
        owner?: string;
        /**
         * Filter by team (requires organization owner parameter)
         */
        team?: string;
        /**
         * Page number of results to return (1-based)
         */
        page?: number;
        /**
         * Number of items per page
         */
        limit?: number;
    };
    url: '/repos/issues/search';
};

export type IssueSearchIssuesErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type IssueSearchIssuesError = IssueSearchIssuesErrors[keyof IssueSearchIssuesErrors];

export type IssueSearchIssuesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueSearchIssuesResponse = IssueSearchIssuesResponses[keyof IssueSearchIssuesResponses];

export type RepoMigrateData = {
    body?: MigrateRepoOptions;
    path?: never;
    query?: never;
    url: '/repos/migrate';
};

export type RepoMigrateErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoMigrateError = RepoMigrateErrors[keyof RepoMigrateErrors];

export type RepoMigrateResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type RepoMigrateResponse = RepoMigrateResponses[keyof RepoMigrateResponses];

export type RepoSearchData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * keyword
         */
        q?: string;
        /**
         * Limit search to repositories with keyword as topic
         */
        topic?: boolean;
        /**
         * include search of keyword within repository description
         */
        includeDesc?: boolean;
        /**
         * search only for repos that the user with the given id owns or contributes to
         */
        uid?: number;
        /**
         * repo owner to prioritize in the results
         */
        priority_owner_id?: number;
        /**
         * search only for repos that belong to the given team id
         */
        team_id?: number;
        /**
         * search only for repos that the user with the given id has starred
         */
        starredBy?: number;
        /**
         * include private repositories this user has access to (defaults to true)
         */
        private?: boolean;
        /**
         * show only public, private or all repositories (defaults to all)
         */
        is_private?: boolean;
        /**
         * include template repositories this user has access to (defaults to true)
         */
        template?: boolean;
        /**
         * show only archived, non-archived or all repositories (defaults to all)
         */
        archived?: boolean;
        /**
         * type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative"
         */
        mode?: string;
        /**
         * if `uid` is given, search only for repos that the user owns
         */
        exclusive?: boolean;
        /**
         * sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha"
         */
        sort?: string;
        /**
         * sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified.
         */
        order?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/search';
};

export type RepoSearchErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoSearchError = RepoSearchErrors[keyof RepoSearchErrors];

export type RepoSearchResponses = {
    /**
     * SearchResults
     */
    200: SearchResults;
};

export type RepoSearchResponse = RepoSearchResponses[keyof RepoSearchResponses];

export type RepoDeleteData = {
    body?: never;
    path: {
        /**
         * owner of the repo to delete
         */
        owner: string;
        /**
         * name of the repo to delete
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}';
};

export type RepoDeleteErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteError = RepoDeleteErrors[keyof RepoDeleteErrors];

export type RepoDeleteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}';
};

export type RepoGetErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetError = RepoGetErrors[keyof RepoGetErrors];

export type RepoGetResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RepoGetResponse = RepoGetResponses[keyof RepoGetResponses];

export type RepoEditData = {
    /**
     * Properties of a repo that you can edit
     */
    body?: EditRepoOption;
    path: {
        /**
         * owner of the repo to edit
         */
        owner: string;
        /**
         * name of the repo to edit
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}';
};

export type RepoEditErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoEditError = RepoEditErrors[keyof RepoEditErrors];

export type RepoEditResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RepoEditResponse = RepoEditResponses[keyof RepoEditResponses];

export type RepoSearchRunJobsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * a comma separated list of run job labels to search for
         */
        labels?: string;
    };
    url: '/repos/{owner}/{repo}/actions/runners/jobs';
};

export type RepoSearchRunJobsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type RepoSearchRunJobsError = RepoSearchRunJobsErrors[keyof RepoSearchRunJobsErrors];

export type RepoSearchRunJobsResponses = {
    /**
     * RunJobList is a list of action run jobs
     */
    200: Array<ActionRunJob>;
};

export type RepoSearchRunJobsResponse = RepoSearchRunJobsResponses[keyof RepoSearchRunJobsResponses];

export type RepoGetRunnerRegistrationTokenData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/runners/registration-token';
};

export type RepoGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is a string used to register a runner with a server
     */
    200: unknown;
};

export type RepoListActionsSecretsData = {
    body?: never;
    path: {
        /**
         * owner of the repository
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/actions/secrets';
};

export type RepoListActionsSecretsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListActionsSecretsError = RepoListActionsSecretsErrors[keyof RepoListActionsSecretsErrors];

export type RepoListActionsSecretsResponses = {
    /**
     * SecretList
     */
    200: Array<Secret>;
};

export type RepoListActionsSecretsResponse = RepoListActionsSecretsResponses[keyof RepoListActionsSecretsResponses];

export type DeleteRepoSecretData = {
    body?: never;
    path: {
        /**
         * owner of the repository
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/secrets/{secretname}';
};

export type DeleteRepoSecretErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeleteRepoSecretError = DeleteRepoSecretErrors[keyof DeleteRepoSecretErrors];

export type DeleteRepoSecretResponses = {
    /**
     * delete one secret of the organization
     */
    204: unknown;
};

export type UpdateRepoSecretData = {
    body?: CreateOrUpdateSecretOption;
    path: {
        /**
         * owner of the repository
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/secrets/{secretname}';
};

export type UpdateRepoSecretErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UpdateRepoSecretError = UpdateRepoSecretErrors[keyof UpdateRepoSecretErrors];

export type UpdateRepoSecretResponses = {
    /**
     * response when creating a secret
     */
    201: unknown;
    /**
     * response when updating a secret
     */
    204: unknown;
};

export type ListActionTasksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results, default maximum page size is 50
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/actions/tasks';
};

export type ListActionTasksErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type ListActionTasksError = ListActionTasksErrors[keyof ListActionTasksErrors];

export type ListActionTasksResponses = {
    /**
     * TasksList
     */
    200: ActionTaskResponse;
};

export type ListActionTasksResponse = ListActionTasksResponses[keyof ListActionTasksResponses];

export type GetRepoVariablesListData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/actions/variables';
};

export type GetRepoVariablesListErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetRepoVariablesListError = GetRepoVariablesListErrors[keyof GetRepoVariablesListErrors];

export type GetRepoVariablesListResponses = {
    /**
     * VariableList
     */
    200: Array<ActionVariable>;
};

export type GetRepoVariablesListResponse = GetRepoVariablesListResponses[keyof GetRepoVariablesListResponses];

export type DeleteRepoVariableData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type DeleteRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeleteRepoVariableError = DeleteRepoVariableErrors[keyof DeleteRepoVariableErrors];

export type DeleteRepoVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
    /**
     * response when deleting a variable
     */
    201: unknown;
    /**
     * response when deleting a variable
     */
    204: unknown;
};

export type DeleteRepoVariableResponse = DeleteRepoVariableResponses[keyof DeleteRepoVariableResponses];

export type GetRepoVariableData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type GetRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetRepoVariableError = GetRepoVariableErrors[keyof GetRepoVariableErrors];

export type GetRepoVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
};

export type GetRepoVariableResponse = GetRepoVariableResponses[keyof GetRepoVariableResponses];

export type CreateRepoVariableData = {
    body?: CreateVariableOption;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type CreateRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type CreateRepoVariableError = CreateRepoVariableErrors[keyof CreateRepoVariableErrors];

export type CreateRepoVariableResponses = {
    /**
     * response when creating a repo-level variable
     */
    201: unknown;
    /**
     * response when creating a repo-level variable
     */
    204: unknown;
};

export type UpdateRepoVariableData = {
    body?: UpdateVariableOption;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type UpdateRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UpdateRepoVariableError = UpdateRepoVariableErrors[keyof UpdateRepoVariableErrors];

export type UpdateRepoVariableResponses = {
    /**
     * response when updating a repo-level variable
     */
    201: unknown;
    /**
     * response when updating a repo-level variable
     */
    204: unknown;
};

export type DispatchWorkflowData = {
    body?: DispatchWorkflowOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the workflow
         */
        workflowname: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/workflows/{workflowname}/dispatches';
};

export type DispatchWorkflowErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DispatchWorkflowError = DispatchWorkflowErrors[keyof DispatchWorkflowErrors];

export type DispatchWorkflowResponses = {
    /**
     * DispatchWorkflowRun is a Workflow Run after dispatching
     */
    201: DispatchWorkflowRun;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type DispatchWorkflowResponse = DispatchWorkflowResponses[keyof DispatchWorkflowResponses];

export type RepoListActivityFeedsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/activities/feeds';
};

export type RepoListActivityFeedsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListActivityFeedsError = RepoListActivityFeedsErrors[keyof RepoListActivityFeedsErrors];

export type RepoListActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type RepoListActivityFeedsResponse = RepoListActivityFeedsResponses[keyof RepoListActivityFeedsResponses];

export type RepoGetArchiveData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the git reference for download with attached archive format (e.g. master.zip)
         */
        archive: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/archive/{archive}';
};

export type RepoGetArchiveErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetArchiveError = RepoGetArchiveErrors[keyof RepoGetArchiveErrors];

export type RepoGetArchiveResponses = {
    /**
     * success
     */
    200: Blob | File;
};

export type RepoGetArchiveResponse = RepoGetArchiveResponses[keyof RepoGetArchiveResponses];

export type RepoGetAssigneesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/assignees';
};

export type RepoGetAssigneesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetAssigneesError = RepoGetAssigneesErrors[keyof RepoGetAssigneesErrors];

export type RepoGetAssigneesResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoGetAssigneesResponse = RepoGetAssigneesResponses[keyof RepoGetAssigneesResponses];

export type RepoDeleteAvatarData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/avatar';
};

export type RepoDeleteAvatarErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteAvatarError = RepoDeleteAvatarErrors[keyof RepoDeleteAvatarErrors];

export type RepoDeleteAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoUpdateAvatarData = {
    body?: UpdateRepoAvatarOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/avatar';
};

export type RepoUpdateAvatarErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoUpdateAvatarError = RepoUpdateAvatarErrors[keyof RepoUpdateAvatarErrors];

export type RepoUpdateAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListBranchProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections';
};

export type RepoListBranchProtectionResponses = {
    /**
     * BranchProtectionList
     */
    200: Array<BranchProtection>;
};

export type RepoListBranchProtectionResponse = RepoListBranchProtectionResponses[keyof RepoListBranchProtectionResponses];

export type RepoCreateBranchProtectionData = {
    body?: CreateBranchProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections';
};

export type RepoCreateBranchProtectionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreateBranchProtectionError = RepoCreateBranchProtectionErrors[keyof RepoCreateBranchProtectionErrors];

export type RepoCreateBranchProtectionResponses = {
    /**
     * BranchProtection
     */
    201: BranchProtection;
};

export type RepoCreateBranchProtectionResponse = RepoCreateBranchProtectionResponses[keyof RepoCreateBranchProtectionResponses];

export type RepoDeleteBranchProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of protected branch
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/{name}';
};

export type RepoDeleteBranchProtectionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteBranchProtectionError = RepoDeleteBranchProtectionErrors[keyof RepoDeleteBranchProtectionErrors];

export type RepoDeleteBranchProtectionResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetBranchProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of protected branch
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/{name}';
};

export type RepoGetBranchProtectionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetBranchProtectionError = RepoGetBranchProtectionErrors[keyof RepoGetBranchProtectionErrors];

export type RepoGetBranchProtectionResponses = {
    /**
     * BranchProtection
     */
    200: BranchProtection;
};

export type RepoGetBranchProtectionResponse = RepoGetBranchProtectionResponses[keyof RepoGetBranchProtectionResponses];

export type RepoEditBranchProtectionData = {
    body?: EditBranchProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of protected branch
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/{name}';
};

export type RepoEditBranchProtectionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoEditBranchProtectionError = RepoEditBranchProtectionErrors[keyof RepoEditBranchProtectionErrors];

export type RepoEditBranchProtectionResponses = {
    /**
     * BranchProtection
     */
    200: BranchProtection;
};

export type RepoEditBranchProtectionResponse = RepoEditBranchProtectionResponses[keyof RepoEditBranchProtectionResponses];

export type RepoListBranchesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/branches';
};

export type RepoListBranchesResponses = {
    /**
     * BranchList
     */
    200: Array<Branch>;
};

export type RepoListBranchesResponse = RepoListBranchesResponses[keyof RepoListBranchesResponses];

export type RepoCreateBranchData = {
    body?: CreateBranchRepoOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches';
};

export type RepoCreateBranchErrors = {
    /**
     * The branch is archived or a mirror.
     */
    403: unknown;
    /**
     * The old branch does not exist.
     */
    404: unknown;
    /**
     * The branch with the same name already exists.
     */
    409: unknown;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreateBranchError = RepoCreateBranchErrors[keyof RepoCreateBranchErrors];

export type RepoCreateBranchResponses = {
    /**
     * Branch
     */
    201: Branch;
};

export type RepoCreateBranchResponse = RepoCreateBranchResponses[keyof RepoCreateBranchResponses];

export type RepoDeleteBranchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * branch to delete
         */
        branch: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches/{branch}';
};

export type RepoDeleteBranchErrors = {
    /**
     * APIError is error format response
     */
    403: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoDeleteBranchError = RepoDeleteBranchErrors[keyof RepoDeleteBranchErrors];

export type RepoDeleteBranchResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetBranchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * branch to get
         */
        branch: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches/{branch}';
};

export type RepoGetBranchErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetBranchError = RepoGetBranchErrors[keyof RepoGetBranchErrors];

export type RepoGetBranchResponses = {
    /**
     * Branch
     */
    200: Branch;
};

export type RepoGetBranchResponse = RepoGetBranchResponses[keyof RepoGetBranchResponses];

export type RepoUpdateBranchData = {
    body?: UpdateBranchRepoOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the branch
         */
        branch: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches/{branch}';
};

export type RepoUpdateBranchErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoUpdateBranchError = RepoUpdateBranchErrors[keyof RepoUpdateBranchErrors];

export type RepoUpdateBranchResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListCollaboratorsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/collaborators';
};

export type RepoListCollaboratorsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListCollaboratorsError = RepoListCollaboratorsErrors[keyof RepoListCollaboratorsErrors];

export type RepoListCollaboratorsResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoListCollaboratorsResponse = RepoListCollaboratorsResponses[keyof RepoListCollaboratorsResponses];

export type RepoDeleteCollaboratorData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator to delete
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}';
};

export type RepoDeleteCollaboratorErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoDeleteCollaboratorError = RepoDeleteCollaboratorErrors[keyof RepoDeleteCollaboratorErrors];

export type RepoDeleteCollaboratorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCheckCollaboratorData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}';
};

export type RepoCheckCollaboratorErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoCheckCollaboratorError = RepoCheckCollaboratorErrors[keyof RepoCheckCollaboratorErrors];

export type RepoCheckCollaboratorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoAddCollaboratorData = {
    body?: AddCollaboratorOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator to add
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}';
};

export type RepoAddCollaboratorErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoAddCollaboratorError = RepoAddCollaboratorErrors[keyof RepoAddCollaboratorErrors];

export type RepoAddCollaboratorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetRepoPermissionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}/permission';
};

export type RepoGetRepoPermissionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetRepoPermissionsError = RepoGetRepoPermissionsErrors[keyof RepoGetRepoPermissionsErrors];

export type RepoGetRepoPermissionsResponses = {
    /**
     * RepoCollaboratorPermission
     */
    200: RepoCollaboratorPermission;
};

export type RepoGetRepoPermissionsResponse = RepoGetRepoPermissionsResponses[keyof RepoGetRepoPermissionsResponses];

export type RepoGetAllCommitsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * SHA or branch to start listing commits from (usually 'master')
         */
        sha?: string;
        /**
         * filepath of a file/dir
         */
        path?: string;
        /**
         * include diff stats for every commit (disable for speedup, default 'true')
         */
        stat?: boolean;
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results (ignored if used with 'path')
         */
        limit?: number;
        /**
         * commits that match the given specifier will not be listed.
         */
        not?: string;
    };
    url: '/repos/{owner}/{repo}/commits';
};

export type RepoGetAllCommitsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * EmptyRepository
     */
    409: ApiError;
};

export type RepoGetAllCommitsError = RepoGetAllCommitsErrors[keyof RepoGetAllCommitsErrors];

export type RepoGetAllCommitsResponses = {
    /**
     * CommitList
     */
    200: Array<Commit>;
};

export type RepoGetAllCommitsResponse = RepoGetAllCommitsResponses[keyof RepoGetAllCommitsResponses];

export type RepoGetCombinedStatusByRefData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of branch/tag/commit
         */
        ref: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/commits/{ref}/status';
};

export type RepoGetCombinedStatusByRefErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetCombinedStatusByRefError = RepoGetCombinedStatusByRefErrors[keyof RepoGetCombinedStatusByRefErrors];

export type RepoGetCombinedStatusByRefResponses = {
    /**
     * CombinedStatus
     */
    200: CombinedStatus;
};

export type RepoGetCombinedStatusByRefResponse = RepoGetCombinedStatusByRefResponses[keyof RepoGetCombinedStatusByRefResponses];

export type RepoListStatusesByRefData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of branch/tag/commit
         */
        ref: string;
    };
    query?: {
        /**
         * type of sort
         */
        sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex';
        /**
         * type of state
         */
        state?: 'pending' | 'success' | 'error' | 'failure' | 'warning';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/commits/{ref}/statuses';
};

export type RepoListStatusesByRefErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListStatusesByRefError = RepoListStatusesByRefErrors[keyof RepoListStatusesByRefErrors];

export type RepoListStatusesByRefResponses = {
    /**
     * CommitStatusList
     */
    200: Array<CommitStatus>;
};

export type RepoListStatusesByRefResponse = RepoListStatusesByRefResponses[keyof RepoListStatusesByRefResponses];

export type RepoGetCommitPullRequestData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * SHA of the commit to get
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/commits/{sha}/pull';
};

export type RepoGetCommitPullRequestErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetCommitPullRequestError = RepoGetCommitPullRequestErrors[keyof RepoGetCommitPullRequestErrors];

export type RepoGetCommitPullRequestResponses = {
    /**
     * PullRequest
     */
    200: PullRequest;
};

export type RepoGetCommitPullRequestResponse = RepoGetCommitPullRequestResponses[keyof RepoGetCommitPullRequestResponses];

export type RepoCompareDiffData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * compare two branches or commits
         */
        basehead: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/compare/{basehead}';
};

export type RepoCompareDiffErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoCompareDiffError = RepoCompareDiffErrors[keyof RepoCompareDiffErrors];

export type RepoCompareDiffResponses = {
    200: Compare;
};

export type RepoCompareDiffResponse = RepoCompareDiffResponses[keyof RepoCompareDiffResponses];

export type RepoGetContentsListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/contents';
};

export type RepoGetContentsListErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetContentsListError = RepoGetContentsListErrors[keyof RepoGetContentsListErrors];

export type RepoGetContentsListResponses = {
    /**
     * ContentsListResponse
     */
    200: Array<ContentsResponse>;
};

export type RepoGetContentsListResponse = RepoGetContentsListResponses[keyof RepoGetContentsListResponses];

export type RepoChangeFilesData = {
    body: ChangeFilesOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents';
};

export type RepoChangeFilesErrors = {
    /**
     * APIError is error format response
     */
    403: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIError is error format response
     */
    422: ApiError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoChangeFilesError = RepoChangeFilesErrors[keyof RepoChangeFilesErrors];

export type RepoChangeFilesResponses = {
    /**
     * FilesResponse
     */
    201: FilesResponse;
};

export type RepoChangeFilesResponse = RepoChangeFilesResponses[keyof RepoChangeFilesResponses];

export type RepoDeleteFileData = {
    body: DeleteFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to delete
         */
        filepath: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoDeleteFileErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIError is error format response
     */
    403: ApiError;
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoDeleteFileError = RepoDeleteFileErrors[keyof RepoDeleteFileErrors];

export type RepoDeleteFileResponses = {
    /**
     * FileDeleteResponse
     */
    200: FileDeleteResponse;
};

export type RepoDeleteFileResponse = RepoDeleteFileResponses[keyof RepoDeleteFileResponses];

export type RepoGetContentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the dir, file, symlink or submodule in the repo
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoGetContentsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetContentsError = RepoGetContentsErrors[keyof RepoGetContentsErrors];

export type RepoGetContentsResponses = {
    /**
     * ContentsResponse
     */
    200: ContentsResponse;
};

export type RepoGetContentsResponse = RepoGetContentsResponses[keyof RepoGetContentsResponses];

export type RepoCreateFileData = {
    body: CreateFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to create
         */
        filepath: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoCreateFileErrors = {
    /**
     * APIError is error format response
     */
    403: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIError is error format response
     */
    422: ApiError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreateFileError = RepoCreateFileErrors[keyof RepoCreateFileErrors];

export type RepoCreateFileResponses = {
    /**
     * FileResponse
     */
    201: FileResponse;
};

export type RepoCreateFileResponse = RepoCreateFileResponses[keyof RepoCreateFileResponses];

export type RepoUpdateFileData = {
    body: UpdateFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to update
         */
        filepath: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoUpdateFileErrors = {
    /**
     * APIError is error format response
     */
    403: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIError is error format response
     */
    422: ApiError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoUpdateFileError = RepoUpdateFileErrors[keyof RepoUpdateFileErrors];

export type RepoUpdateFileResponses = {
    /**
     * FileResponse
     */
    200: FileResponse;
};

export type RepoUpdateFileResponse = RepoUpdateFileResponses[keyof RepoUpdateFileResponses];

export type RepoApplyDiffPatchData = {
    body: UpdateFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/diffpatch';
};

export type RepoApplyDiffPatchErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoApplyDiffPatchError = RepoApplyDiffPatchErrors[keyof RepoApplyDiffPatchErrors];

export type RepoApplyDiffPatchResponses = {
    /**
     * FileResponse
     */
    200: FileResponse;
};

export type RepoApplyDiffPatchResponse = RepoApplyDiffPatchResponses[keyof RepoApplyDiffPatchResponses];

export type RepoGetEditorConfigData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * filepath of file to get
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/editorconfig/{filepath}';
};

export type RepoGetEditorConfigErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetEditorConfigError = RepoGetEditorConfigErrors[keyof RepoGetEditorConfigErrors];

export type RepoGetEditorConfigResponses = {
    /**
     * success
     */
    200: unknown;
};

export type RepoDeleteAllFlagsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/flags';
};

export type RepoDeleteAllFlagsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteAllFlagsError = RepoDeleteAllFlagsErrors[keyof RepoDeleteAllFlagsErrors];

export type RepoDeleteAllFlagsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListFlagsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/flags';
};

export type RepoListFlagsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListFlagsError = RepoListFlagsErrors[keyof RepoListFlagsErrors];

export type RepoListFlagsResponses = {
    /**
     * StringSlice
     */
    200: Array<string>;
};

export type RepoListFlagsResponse = RepoListFlagsResponses[keyof RepoListFlagsResponses];

export type RepoReplaceAllFlagsData = {
    body?: ReplaceFlagsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/flags';
};

export type RepoReplaceAllFlagsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoReplaceAllFlagsError = RepoReplaceAllFlagsErrors[keyof RepoReplaceAllFlagsErrors];

export type RepoReplaceAllFlagsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoDeleteFlagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the flag
         */
        flag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/flags/{flag}';
};

export type RepoDeleteFlagErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteFlagError = RepoDeleteFlagErrors[keyof RepoDeleteFlagErrors];

export type RepoDeleteFlagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCheckFlagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the flag
         */
        flag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/flags/{flag}';
};

export type RepoCheckFlagErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoCheckFlagError = RepoCheckFlagErrors[keyof RepoCheckFlagErrors];

export type RepoCheckFlagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoAddFlagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the flag
         */
        flag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/flags/{flag}';
};

export type RepoAddFlagErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoAddFlagError = RepoAddFlagErrors[keyof RepoAddFlagErrors];

export type RepoAddFlagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type ListForksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/forks';
};

export type ListForksErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type ListForksError = ListForksErrors[keyof ListForksErrors];

export type ListForksResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type ListForksResponse = ListForksResponses[keyof ListForksResponses];

export type CreateForkData = {
    body?: CreateForkOption;
    path: {
        /**
         * owner of the repo to fork
         */
        owner: string;
        /**
         * name of the repo to fork
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/forks';
};

export type CreateForkErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type CreateForkError = CreateForkErrors[keyof CreateForkErrors];

export type CreateForkResponses = {
    /**
     * Repository
     */
    202: Repository;
};

export type CreateForkResponse = CreateForkResponses[keyof CreateForkResponses];

export type GetBlobData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/blobs/{sha}';
};

export type GetBlobErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetBlobError = GetBlobErrors[keyof GetBlobErrors];

export type GetBlobResponses = {
    /**
     * GitBlobResponse
     */
    200: GitBlobResponse;
};

export type GetBlobResponse = GetBlobResponses[keyof GetBlobResponses];

export type RepoGetSingleCommitData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * a git ref or commit sha
         */
        sha: string;
    };
    query?: {
        /**
         * include diff stats for every commit (disable for speedup, default 'true')
         */
        stat?: boolean;
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
    };
    url: '/repos/{owner}/{repo}/git/commits/{sha}';
};

export type RepoGetSingleCommitErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoGetSingleCommitError = RepoGetSingleCommitErrors[keyof RepoGetSingleCommitErrors];

export type RepoGetSingleCommitResponses = {
    /**
     * Commit
     */
    200: Commit;
};

export type RepoGetSingleCommitResponse = RepoGetSingleCommitResponses[keyof RepoGetSingleCommitResponses];

export type RepoDownloadCommitDiffOrPatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * SHA of the commit to get
         */
        sha: string;
        /**
         * whether the output is diff or patch
         */
        diffType: 'diff' | 'patch';
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/commits/{sha}.{diffType}';
};

export type RepoDownloadCommitDiffOrPatchErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDownloadCommitDiffOrPatchError = RepoDownloadCommitDiffOrPatchErrors[keyof RepoDownloadCommitDiffOrPatchErrors];

export type RepoDownloadCommitDiffOrPatchResponses = {
    /**
     * APIString is a string response
     */
    200: string;
};

export type RepoDownloadCommitDiffOrPatchResponse = RepoDownloadCommitDiffOrPatchResponses[keyof RepoDownloadCommitDiffOrPatchResponses];

export type RepoRemoveNoteData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * a git ref or commit sha
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/notes/{sha}';
};

export type RepoRemoveNoteErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoRemoveNoteError = RepoRemoveNoteErrors[keyof RepoRemoveNoteErrors];

export type RepoRemoveNoteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetNoteData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * a git ref or commit sha
         */
        sha: string;
    };
    query?: {
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
    };
    url: '/repos/{owner}/{repo}/git/notes/{sha}';
};

export type RepoGetNoteErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoGetNoteError = RepoGetNoteErrors[keyof RepoGetNoteErrors];

export type RepoGetNoteResponses = {
    /**
     * Note
     */
    200: Note;
};

export type RepoGetNoteResponse = RepoGetNoteResponses[keyof RepoGetNoteResponses];

export type RepoSetNoteData = {
    body?: NoteOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * a git ref or commit sha
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/notes/{sha}';
};

export type RepoSetNoteErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoSetNoteError = RepoSetNoteErrors[keyof RepoSetNoteErrors];

export type RepoSetNoteResponses = {
    /**
     * Note
     */
    200: Note;
};

export type RepoSetNoteResponse = RepoSetNoteResponses[keyof RepoSetNoteResponses];

export type RepoListAllGitRefsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/refs';
};

export type RepoListAllGitRefsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListAllGitRefsError = RepoListAllGitRefsErrors[keyof RepoListAllGitRefsErrors];

export type RepoListAllGitRefsResponses = {
    /**
     * ReferenceList
     */
    200: Array<Reference>;
};

export type RepoListAllGitRefsResponse = RepoListAllGitRefsResponses[keyof RepoListAllGitRefsResponses];

export type RepoListGitRefsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * part or full name of the ref
         */
        ref: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/refs/{ref}';
};

export type RepoListGitRefsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListGitRefsError = RepoListGitRefsErrors[keyof RepoListGitRefsErrors];

export type RepoListGitRefsResponses = {
    /**
     * ReferenceList
     */
    200: Array<Reference>;
};

export type RepoListGitRefsResponse = RepoListGitRefsResponses[keyof RepoListGitRefsResponses];

export type GetAnnotatedTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/tags/{sha}';
};

export type GetAnnotatedTagErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetAnnotatedTagError = GetAnnotatedTagErrors[keyof GetAnnotatedTagErrors];

export type GetAnnotatedTagResponses = {
    /**
     * AnnotatedTag
     */
    200: AnnotatedTag;
};

export type GetAnnotatedTagResponse = GetAnnotatedTagResponses[keyof GetAnnotatedTagResponses];

export type GetTreeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: {
        /**
         * show all directories and files
         */
        recursive?: boolean;
        /**
         * page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
         */
        page?: number;
        /**
         * number of items per page
         */
        per_page?: number;
    };
    url: '/repos/{owner}/{repo}/git/trees/{sha}';
};

export type GetTreeErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetTreeError = GetTreeErrors[keyof GetTreeErrors];

export type GetTreeResponses = {
    /**
     * GitTreeResponse
     */
    200: GitTreeResponse;
};

export type GetTreeResponse = GetTreeResponses[keyof GetTreeResponses];

export type RepoListHooksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/hooks';
};

export type RepoListHooksErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListHooksError = RepoListHooksErrors[keyof RepoListHooksErrors];

export type RepoListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type RepoListHooksResponse = RepoListHooksResponses[keyof RepoListHooksResponses];

export type RepoCreateHookData = {
    body?: CreateHookOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks';
};

export type RepoCreateHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoCreateHookError = RepoCreateHookErrors[keyof RepoCreateHookErrors];

export type RepoCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type RepoCreateHookResponse = RepoCreateHookResponses[keyof RepoCreateHookResponses];

export type RepoListGitHooksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git';
};

export type RepoListGitHooksErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListGitHooksError = RepoListGitHooksErrors[keyof RepoListGitHooksErrors];

export type RepoListGitHooksResponses = {
    /**
     * GitHookList
     */
    200: Array<GitHook>;
};

export type RepoListGitHooksResponse = RepoListGitHooksResponses[keyof RepoListGitHooksResponses];

export type RepoDeleteGitHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git/{id}';
};

export type RepoDeleteGitHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteGitHookError = RepoDeleteGitHookErrors[keyof RepoDeleteGitHookErrors];

export type RepoDeleteGitHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetGitHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git/{id}';
};

export type RepoGetGitHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetGitHookError = RepoGetGitHookErrors[keyof RepoGetGitHookErrors];

export type RepoGetGitHookResponses = {
    /**
     * GitHook
     */
    200: GitHook;
};

export type RepoGetGitHookResponse = RepoGetGitHookResponses[keyof RepoGetGitHookResponses];

export type RepoEditGitHookData = {
    body?: EditGitHookOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git/{id}';
};

export type RepoEditGitHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoEditGitHookError = RepoEditGitHookErrors[keyof RepoEditGitHookErrors];

export type RepoEditGitHookResponses = {
    /**
     * GitHook
     */
    200: GitHook;
};

export type RepoEditGitHookResponse = RepoEditGitHookResponses[keyof RepoEditGitHookResponses];

export type RepoDeleteHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/{id}';
};

export type RepoDeleteHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteHookError = RepoDeleteHookErrors[keyof RepoDeleteHookErrors];

export type RepoDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/{id}';
};

export type RepoGetHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetHookError = RepoGetHookErrors[keyof RepoGetHookErrors];

export type RepoGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type RepoGetHookResponse = RepoGetHookResponses[keyof RepoGetHookResponses];

export type RepoEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the hook
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/{id}';
};

export type RepoEditHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoEditHookError = RepoEditHookErrors[keyof RepoEditHookErrors];

export type RepoEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type RepoEditHookResponse = RepoEditHookResponses[keyof RepoEditHookResponses];

export type RepoTestHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to test
         */
        id: number;
    };
    query?: {
        /**
         * The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/hooks/{id}/tests';
};

export type RepoTestHookErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoTestHookError = RepoTestHookErrors[keyof RepoTestHookErrors];

export type RepoTestHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetIssueConfigData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issue_config';
};

export type RepoGetIssueConfigErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetIssueConfigError = RepoGetIssueConfigErrors[keyof RepoGetIssueConfigErrors];

export type RepoGetIssueConfigResponses = {
    /**
     * RepoIssueConfig
     */
    200: IssueConfig;
};

export type RepoGetIssueConfigResponse = RepoGetIssueConfigResponses[keyof RepoGetIssueConfigResponses];

export type RepoValidateIssueConfigData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issue_config/validate';
};

export type RepoValidateIssueConfigErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoValidateIssueConfigError = RepoValidateIssueConfigErrors[keyof RepoValidateIssueConfigErrors];

export type RepoValidateIssueConfigResponses = {
    /**
     * RepoIssueConfigValidation
     */
    200: IssueConfigValidation;
};

export type RepoValidateIssueConfigResponse = RepoValidateIssueConfigResponses[keyof RepoValidateIssueConfigResponses];

export type RepoGetIssueTemplatesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issue_templates';
};

export type RepoGetIssueTemplatesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetIssueTemplatesError = RepoGetIssueTemplatesErrors[keyof RepoGetIssueTemplatesErrors];

export type RepoGetIssueTemplatesResponses = {
    /**
     * IssueTemplates
     */
    200: Array<IssueTemplate>;
};

export type RepoGetIssueTemplatesResponse = RepoGetIssueTemplatesResponses[keyof RepoGetIssueTemplatesResponses];

export type IssueListIssuesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * whether issue is open or closed
         */
        state?: 'closed' | 'open' | 'all';
        /**
         * comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         */
        labels?: string;
        /**
         * search string
         */
        q?: string;
        /**
         * filter by type (issues / pulls) if set
         */
        type?: 'issues' | 'pulls';
        /**
         * comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         */
        milestones?: string;
        /**
         * Only show items updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show items updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * Only show items which were created by the given user
         */
        created_by?: string;
        /**
         * Only show items for which the given user is assigned
         */
        assigned_by?: string;
        /**
         * Only show items in which the given user was mentioned
         */
        mentioned_by?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * Type of sort
         */
        sort?: 'relevance' | 'latest' | 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'nearduedate' | 'farduedate';
    };
    url: '/repos/{owner}/{repo}/issues';
};

export type IssueListIssuesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueListIssuesError = IssueListIssuesErrors[keyof IssueListIssuesErrors];

export type IssueListIssuesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueListIssuesResponse = IssueListIssuesResponses[keyof IssueListIssuesResponses];

export type IssueCreateIssueData = {
    body?: CreateIssueOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues';
};

export type IssueCreateIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    412: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueCreateIssueError = IssueCreateIssueErrors[keyof IssueCreateIssueErrors];

export type IssueCreateIssueResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueCreateIssueResponse = IssueCreateIssueResponses[keyof IssueCreateIssueResponses];

export type IssueGetRepoCommentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * if provided, only comments updated since the provided time are returned.
         */
        since?: string;
        /**
         * if provided, only comments updated before the provided time are returned.
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/comments';
};

export type IssueGetRepoCommentsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueGetRepoCommentsError = IssueGetRepoCommentsErrors[keyof IssueGetRepoCommentsErrors];

export type IssueGetRepoCommentsResponses = {
    /**
     * CommentList
     */
    200: Array<Comment>;
};

export type IssueGetRepoCommentsResponse = IssueGetRepoCommentsResponses[keyof IssueGetRepoCommentsResponses];

export type IssueDeleteCommentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of comment to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}';
};

export type IssueDeleteCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueDeleteCommentError = IssueDeleteCommentErrors[keyof IssueDeleteCommentErrors];

export type IssueDeleteCommentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetCommentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}';
};

export type IssueGetCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueGetCommentError = IssueGetCommentErrors[keyof IssueGetCommentErrors];

export type IssueGetCommentResponses = {
    /**
     * Comment
     */
    200: Comment;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetCommentResponse = IssueGetCommentResponses[keyof IssueGetCommentResponses];

export type IssueEditCommentData = {
    body?: EditIssueCommentOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}';
};

export type IssueEditCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueEditCommentError = IssueEditCommentErrors[keyof IssueEditCommentErrors];

export type IssueEditCommentResponses = {
    /**
     * Comment
     */
    200: Comment;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueEditCommentResponse = IssueEditCommentResponses[keyof IssueEditCommentResponses];

export type IssueListIssueCommentAttachmentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets';
};

export type IssueListIssueCommentAttachmentsErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
};

export type IssueListIssueCommentAttachmentsError = IssueListIssueCommentAttachmentsErrors[keyof IssueListIssueCommentAttachmentsErrors];

export type IssueListIssueCommentAttachmentsResponses = {
    /**
     * AttachmentList
     */
    200: Array<Attachment>;
};

export type IssueListIssueCommentAttachmentsResponse = IssueListIssueCommentAttachmentsResponses[keyof IssueListIssueCommentAttachmentsResponses];

export type IssueCreateIssueCommentAttachmentData = {
    body: {
        /**
         * attachment to upload
         */
        attachment: Blob | File;
    };
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
    };
    query?: {
        /**
         * name of the attachment
         */
        name?: string;
        /**
         * time of the attachment's creation. This is a timestamp in RFC 3339 format
         */
        updated_at?: string;
    };
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets';
};

export type IssueCreateIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueCreateIssueCommentAttachmentError = IssueCreateIssueCommentAttachmentErrors[keyof IssueCreateIssueCommentAttachmentErrors];

export type IssueCreateIssueCommentAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueCreateIssueCommentAttachmentResponse = IssueCreateIssueCommentAttachmentResponses[keyof IssueCreateIssueCommentAttachmentResponses];

export type IssueDeleteIssueCommentAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
        /**
         * id of the attachment to delete
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}';
};

export type IssueDeleteIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueDeleteIssueCommentAttachmentError = IssueDeleteIssueCommentAttachmentErrors[keyof IssueDeleteIssueCommentAttachmentErrors];

export type IssueDeleteIssueCommentAttachmentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetIssueCommentAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
        /**
         * id of the attachment to get
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}';
};

export type IssueGetIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
};

export type IssueGetIssueCommentAttachmentError = IssueGetIssueCommentAttachmentErrors[keyof IssueGetIssueCommentAttachmentErrors];

export type IssueGetIssueCommentAttachmentResponses = {
    /**
     * Attachment
     */
    200: Attachment;
};

export type IssueGetIssueCommentAttachmentResponse = IssueGetIssueCommentAttachmentResponses[keyof IssueGetIssueCommentAttachmentResponses];

export type IssueEditIssueCommentAttachmentData = {
    body?: EditAttachmentOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
        /**
         * id of the attachment to edit
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}';
};

export type IssueEditIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueEditIssueCommentAttachmentError = IssueEditIssueCommentAttachmentErrors[keyof IssueEditIssueCommentAttachmentErrors];

export type IssueEditIssueCommentAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueEditIssueCommentAttachmentResponse = IssueEditIssueCommentAttachmentResponses[keyof IssueEditIssueCommentAttachmentResponses];

export type IssueDeleteCommentReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
};

export type IssueDeleteCommentReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteCommentReactionError = IssueDeleteCommentReactionErrors[keyof IssueDeleteCommentReactionErrors];

export type IssueDeleteCommentReactionResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type IssueGetCommentReactionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
};

export type IssueGetCommentReactionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetCommentReactionsError = IssueGetCommentReactionsErrors[keyof IssueGetCommentReactionsErrors];

export type IssueGetCommentReactionsResponses = {
    /**
     * ReactionList
     */
    200: Array<Reaction>;
};

export type IssueGetCommentReactionsResponse = IssueGetCommentReactionsResponses[keyof IssueGetCommentReactionsResponses];

export type IssuePostCommentReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
};

export type IssuePostCommentReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssuePostCommentReactionError = IssuePostCommentReactionErrors[keyof IssuePostCommentReactionErrors];

export type IssuePostCommentReactionResponses = {
    /**
     * Reaction
     */
    200: Reaction;
    /**
     * Reaction
     */
    201: Reaction;
};

export type IssuePostCommentReactionResponse = IssuePostCommentReactionResponses[keyof IssuePostCommentReactionResponses];

export type RepoListPinnedIssuesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/pinned';
};

export type RepoListPinnedIssuesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListPinnedIssuesError = RepoListPinnedIssuesErrors[keyof RepoListPinnedIssuesErrors];

export type RepoListPinnedIssuesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type RepoListPinnedIssuesResponse = RepoListPinnedIssuesResponses[keyof RepoListPinnedIssuesResponses];

export type IssueDeleteData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue to delete
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}';
};

export type IssueDeleteErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteError = IssueDeleteErrors[keyof IssueDeleteErrors];

export type IssueDeleteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetIssueData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to get
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}';
};

export type IssueGetIssueErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetIssueError = IssueGetIssueErrors[keyof IssueGetIssueErrors];

export type IssueGetIssueResponses = {
    /**
     * Issue
     */
    200: Issue;
};

export type IssueGetIssueResponse = IssueGetIssueResponses[keyof IssueGetIssueResponses];

export type IssueEditIssueData = {
    body?: EditIssueOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to edit
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}';
};

export type IssueEditIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    412: ApiError;
};

export type IssueEditIssueError = IssueEditIssueErrors[keyof IssueEditIssueErrors];

export type IssueEditIssueResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueEditIssueResponse = IssueEditIssueResponses[keyof IssueEditIssueResponses];

export type IssueListIssueAttachmentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets';
};

export type IssueListIssueAttachmentsErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
};

export type IssueListIssueAttachmentsError = IssueListIssueAttachmentsErrors[keyof IssueListIssueAttachmentsErrors];

export type IssueListIssueAttachmentsResponses = {
    /**
     * AttachmentList
     */
    200: Array<Attachment>;
};

export type IssueListIssueAttachmentsResponse = IssueListIssueAttachmentsResponses[keyof IssueListIssueAttachmentsResponses];

export type IssueCreateIssueAttachmentData = {
    body: {
        /**
         * attachment to upload
         */
        attachment: Blob | File;
    };
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * name of the attachment
         */
        name?: string;
        /**
         * time of the attachment's creation. This is a timestamp in RFC 3339 format
         */
        updated_at?: string;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/assets';
};

export type IssueCreateIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueCreateIssueAttachmentError = IssueCreateIssueAttachmentErrors[keyof IssueCreateIssueAttachmentErrors];

export type IssueCreateIssueAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueCreateIssueAttachmentResponse = IssueCreateIssueAttachmentResponses[keyof IssueCreateIssueAttachmentResponses];

export type IssueDeleteIssueAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the attachment to delete
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}';
};

export type IssueDeleteIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueDeleteIssueAttachmentError = IssueDeleteIssueAttachmentErrors[keyof IssueDeleteIssueAttachmentErrors];

export type IssueDeleteIssueAttachmentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetIssueAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the attachment to get
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}';
};

export type IssueGetIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
};

export type IssueGetIssueAttachmentError = IssueGetIssueAttachmentErrors[keyof IssueGetIssueAttachmentErrors];

export type IssueGetIssueAttachmentResponses = {
    /**
     * Attachment
     */
    200: Attachment;
};

export type IssueGetIssueAttachmentResponse = IssueGetIssueAttachmentResponses[keyof IssueGetIssueAttachmentResponses];

export type IssueEditIssueAttachmentData = {
    body?: EditAttachmentOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the attachment to edit
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}';
};

export type IssueEditIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueEditIssueAttachmentError = IssueEditIssueAttachmentErrors[keyof IssueEditIssueAttachmentErrors];

export type IssueEditIssueAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueEditIssueAttachmentResponse = IssueEditIssueAttachmentResponses[keyof IssueEditIssueAttachmentResponses];

export type IssueRemoveIssueBlockingData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/blocks';
};

export type IssueRemoveIssueBlockingErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueRemoveIssueBlockingError = IssueRemoveIssueBlockingErrors[keyof IssueRemoveIssueBlockingErrors];

export type IssueRemoveIssueBlockingResponses = {
    /**
     * Issue
     */
    200: Issue;
};

export type IssueRemoveIssueBlockingResponse = IssueRemoveIssueBlockingResponses[keyof IssueRemoveIssueBlockingResponses];

export type IssueListBlocksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/blocks';
};

export type IssueListBlocksErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueListBlocksError = IssueListBlocksErrors[keyof IssueListBlocksErrors];

export type IssueListBlocksResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueListBlocksResponse = IssueListBlocksResponses[keyof IssueListBlocksResponses];

export type IssueCreateIssueBlockingData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/blocks';
};

export type IssueCreateIssueBlockingErrors = {
    /**
     * the issue does not exist
     */
    404: unknown;
};

export type IssueCreateIssueBlockingResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueCreateIssueBlockingResponse = IssueCreateIssueBlockingResponses[keyof IssueCreateIssueBlockingResponses];

export type IssueGetCommentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * if provided, only comments updated since the specified time are returned.
         */
        since?: string;
        /**
         * if provided, only comments updated before the provided time are returned.
         */
        before?: string;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/comments';
};

export type IssueGetCommentsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueGetCommentsError = IssueGetCommentsErrors[keyof IssueGetCommentsErrors];

export type IssueGetCommentsResponses = {
    /**
     * CommentList
     */
    200: Array<Comment>;
};

export type IssueGetCommentsResponse = IssueGetCommentsResponses[keyof IssueGetCommentsResponses];

export type IssueCreateCommentData = {
    body?: CreateIssueCommentOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/comments';
};

export type IssueCreateCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueCreateCommentError = IssueCreateCommentErrors[keyof IssueCreateCommentErrors];

export type IssueCreateCommentResponses = {
    /**
     * Comment
     */
    201: Comment;
};

export type IssueCreateCommentResponse = IssueCreateCommentResponses[keyof IssueCreateCommentResponses];

export type IssueDeleteCommentDeprecatedData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * this parameter is ignored
         */
        index: number;
        /**
         * id of comment to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/comments/{id}';
};

export type IssueDeleteCommentDeprecatedErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueDeleteCommentDeprecatedError = IssueDeleteCommentDeprecatedErrors[keyof IssueDeleteCommentDeprecatedErrors];

export type IssueDeleteCommentDeprecatedResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueEditCommentDeprecatedData = {
    body?: EditIssueCommentOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * this parameter is ignored
         */
        index: number;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/comments/{id}';
};

export type IssueEditCommentDeprecatedErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueEditCommentDeprecatedError = IssueEditCommentDeprecatedErrors[keyof IssueEditCommentDeprecatedErrors];

export type IssueEditCommentDeprecatedResponses = {
    /**
     * Comment
     */
    200: Comment;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueEditCommentDeprecatedResponse = IssueEditCommentDeprecatedResponses[keyof IssueEditCommentDeprecatedResponses];

export type IssueEditIssueDeadlineData = {
    body?: EditDeadlineOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to create or update a deadline on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/deadline';
};

export type IssueEditIssueDeadlineErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueEditIssueDeadlineError = IssueEditIssueDeadlineErrors[keyof IssueEditIssueDeadlineErrors];

export type IssueEditIssueDeadlineResponses = {
    /**
     * IssueDeadline
     */
    201: IssueDeadline;
};

export type IssueEditIssueDeadlineResponse = IssueEditIssueDeadlineResponses[keyof IssueEditIssueDeadlineResponses];

export type IssueRemoveIssueDependenciesData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/dependencies';
};

export type IssueRemoveIssueDependenciesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueRemoveIssueDependenciesError = IssueRemoveIssueDependenciesErrors[keyof IssueRemoveIssueDependenciesErrors];

export type IssueRemoveIssueDependenciesResponses = {
    /**
     * Issue
     */
    200: Issue;
};

export type IssueRemoveIssueDependenciesResponse = IssueRemoveIssueDependenciesResponses[keyof IssueRemoveIssueDependenciesResponses];

export type IssueListIssueDependenciesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/dependencies';
};

export type IssueListIssueDependenciesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueListIssueDependenciesError = IssueListIssueDependenciesErrors[keyof IssueListIssueDependenciesErrors];

export type IssueListIssueDependenciesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueListIssueDependenciesResponse = IssueListIssueDependenciesResponses[keyof IssueListIssueDependenciesResponses];

export type IssueCreateIssueDependenciesData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/dependencies';
};

export type IssueCreateIssueDependenciesErrors = {
    /**
     * the issue does not exist
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type IssueCreateIssueDependenciesError = IssueCreateIssueDependenciesErrors[keyof IssueCreateIssueDependenciesErrors];

export type IssueCreateIssueDependenciesResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueCreateIssueDependenciesResponse = IssueCreateIssueDependenciesResponses[keyof IssueCreateIssueDependenciesResponses];

export type IssueClearLabelsData = {
    body?: DeleteLabelsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueClearLabelsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueClearLabelsError = IssueClearLabelsErrors[keyof IssueClearLabelsErrors];

export type IssueClearLabelsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetLabelsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueGetLabelsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetLabelsError = IssueGetLabelsErrors[keyof IssueGetLabelsErrors];

export type IssueGetLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueGetLabelsResponse = IssueGetLabelsResponses[keyof IssueGetLabelsResponses];

export type IssueAddLabelData = {
    body?: IssueLabelsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueAddLabelErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueAddLabelError = IssueAddLabelErrors[keyof IssueAddLabelErrors];

export type IssueAddLabelResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueAddLabelResponse = IssueAddLabelResponses[keyof IssueAddLabelResponses];

export type IssueReplaceLabelsData = {
    body?: IssueLabelsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueReplaceLabelsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueReplaceLabelsError = IssueReplaceLabelsErrors[keyof IssueReplaceLabelsErrors];

export type IssueReplaceLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueReplaceLabelsResponse = IssueReplaceLabelsResponses[keyof IssueReplaceLabelsResponses];

export type IssueRemoveLabelData = {
    body?: DeleteLabelsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the label to remove
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels/{id}';
};

export type IssueRemoveLabelErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type IssueRemoveLabelError = IssueRemoveLabelErrors[keyof IssueRemoveLabelErrors];

export type IssueRemoveLabelResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UnpinIssueData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue to unpin
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/pin';
};

export type UnpinIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UnpinIssueError = UnpinIssueErrors[keyof UnpinIssueErrors];

export type UnpinIssueResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type PinIssueData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue to pin
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/pin';
};

export type PinIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type PinIssueError = PinIssueErrors[keyof PinIssueErrors];

export type PinIssueResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type MoveIssuePinData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue
         */
        index: number;
        /**
         * the new position
         */
        position: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/pin/{position}';
};

export type MoveIssuePinErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type MoveIssuePinError = MoveIssuePinErrors[keyof MoveIssuePinErrors];

export type MoveIssuePinResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueDeleteIssueReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/reactions';
};

export type IssueDeleteIssueReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteIssueReactionError = IssueDeleteIssueReactionErrors[keyof IssueDeleteIssueReactionErrors];

export type IssueDeleteIssueReactionResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type IssueGetIssueReactionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/reactions';
};

export type IssueGetIssueReactionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetIssueReactionsError = IssueGetIssueReactionsErrors[keyof IssueGetIssueReactionsErrors];

export type IssueGetIssueReactionsResponses = {
    /**
     * ReactionList
     */
    200: Array<Reaction>;
};

export type IssueGetIssueReactionsResponse = IssueGetIssueReactionsResponses[keyof IssueGetIssueReactionsResponses];

export type IssuePostIssueReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/reactions';
};

export type IssuePostIssueReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssuePostIssueReactionError = IssuePostIssueReactionErrors[keyof IssuePostIssueReactionErrors];

export type IssuePostIssueReactionResponses = {
    /**
     * Reaction
     */
    200: Reaction;
    /**
     * Reaction
     */
    201: Reaction;
};

export type IssuePostIssueReactionResponse = IssuePostIssueReactionResponses[keyof IssuePostIssueReactionResponses];

export type IssueDeleteStopWatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to stop the stopwatch on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/stopwatch/delete';
};

export type IssueDeleteStopWatchErrors = {
    /**
     * Not repo writer, user does not have rights to toggle stopwatch
     */
    403: unknown;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * Cannot cancel a non existent stopwatch
     */
    409: unknown;
};

export type IssueDeleteStopWatchError = IssueDeleteStopWatchErrors[keyof IssueDeleteStopWatchErrors];

export type IssueDeleteStopWatchResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueStartStopWatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to create the stopwatch on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/stopwatch/start';
};

export type IssueStartStopWatchErrors = {
    /**
     * Not repo writer, user does not have rights to toggle stopwatch
     */
    403: unknown;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * Cannot start a stopwatch again if it already exists
     */
    409: unknown;
};

export type IssueStartStopWatchError = IssueStartStopWatchErrors[keyof IssueStartStopWatchErrors];

export type IssueStartStopWatchResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type IssueStopStopWatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to stop the stopwatch on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/stopwatch/stop';
};

export type IssueStopStopWatchErrors = {
    /**
     * Not repo writer, user does not have rights to toggle stopwatch
     */
    403: unknown;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * Cannot stop a non existent stopwatch
     */
    409: unknown;
};

export type IssueStopStopWatchError = IssueStopStopWatchErrors[keyof IssueStopStopWatchErrors];

export type IssueStopStopWatchResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type IssueSubscriptionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions';
};

export type IssueSubscriptionsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueSubscriptionsError = IssueSubscriptionsErrors[keyof IssueSubscriptionsErrors];

export type IssueSubscriptionsResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type IssueSubscriptionsResponse = IssueSubscriptionsResponses[keyof IssueSubscriptionsResponses];

export type IssueCheckSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions/check';
};

export type IssueCheckSubscriptionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueCheckSubscriptionError = IssueCheckSubscriptionErrors[keyof IssueCheckSubscriptionErrors];

export type IssueCheckSubscriptionResponses = {
    /**
     * WatchInfo
     */
    200: WatchInfo;
};

export type IssueCheckSubscriptionResponse = IssueCheckSubscriptionResponses[keyof IssueCheckSubscriptionResponses];

export type IssueDeleteSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * user witch unsubscribe
         */
        user: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}';
};

export type IssueDeleteSubscriptionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteSubscriptionError = IssueDeleteSubscriptionErrors[keyof IssueDeleteSubscriptionErrors];

export type IssueDeleteSubscriptionResponses = {
    /**
     * Already unsubscribed
     */
    200: unknown;
    /**
     * Successfully Unsubscribed
     */
    201: unknown;
};

export type IssueAddSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * user to subscribe
         */
        user: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}';
};

export type IssueAddSubscriptionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueAddSubscriptionError = IssueAddSubscriptionErrors[keyof IssueAddSubscriptionErrors];

export type IssueAddSubscriptionResponses = {
    /**
     * Already subscribed
     */
    200: unknown;
    /**
     * Successfully Subscribed
     */
    201: unknown;
};

export type IssueGetCommentsAndTimelineData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * if provided, only comments updated since the specified time are returned.
         */
        since?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * if provided, only comments updated before the provided time are returned.
         */
        before?: string;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/timeline';
};

export type IssueGetCommentsAndTimelineErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIInternalServerError is an error that is raised when an internal server error occurs
     */
    500: ApiInternalServerError;
};

export type IssueGetCommentsAndTimelineError = IssueGetCommentsAndTimelineErrors[keyof IssueGetCommentsAndTimelineErrors];

export type IssueGetCommentsAndTimelineResponses = {
    /**
     * TimelineList
     */
    200: Array<TimelineComment>;
};

export type IssueGetCommentsAndTimelineResponse = IssueGetCommentsAndTimelineResponses[keyof IssueGetCommentsAndTimelineResponses];

export type IssueResetTimeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to add tracked time to
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/times';
};

export type IssueResetTimeErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueResetTimeError = IssueResetTimeErrors[keyof IssueResetTimeErrors];

export type IssueResetTimeResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueTrackedTimesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * optional filter by user (available for issue managers)
         */
        user?: string;
        /**
         * Only show times updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show times updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/times';
};

export type IssueTrackedTimesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueTrackedTimesError = IssueTrackedTimesErrors[keyof IssueTrackedTimesErrors];

export type IssueTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type IssueTrackedTimesResponse = IssueTrackedTimesResponses[keyof IssueTrackedTimesResponses];

export type IssueAddTimeData = {
    body?: AddTimeOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/times';
};

export type IssueAddTimeErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueAddTimeError = IssueAddTimeErrors[keyof IssueAddTimeErrors];

export type IssueAddTimeResponses = {
    /**
     * TrackedTime
     */
    200: TrackedTime;
};

export type IssueAddTimeResponse = IssueAddTimeResponses[keyof IssueAddTimeResponses];

export type IssueDeleteTimeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of time to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/times/{id}';
};

export type IssueDeleteTimeErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteTimeError = IssueDeleteTimeErrors[keyof IssueDeleteTimeErrors];

export type IssueDeleteTimeResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListKeysData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * the key_id to search for
         */
        key_id?: number;
        /**
         * fingerprint of the key
         */
        fingerprint?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/keys';
};

export type RepoListKeysErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListKeysError = RepoListKeysErrors[keyof RepoListKeysErrors];

export type RepoListKeysResponses = {
    /**
     * DeployKeyList
     */
    200: Array<DeployKey>;
};

export type RepoListKeysResponse = RepoListKeysResponses[keyof RepoListKeysResponses];

export type RepoCreateKeyData = {
    body?: CreateKeyOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/keys';
};

export type RepoCreateKeyErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoCreateKeyError = RepoCreateKeyErrors[keyof RepoCreateKeyErrors];

export type RepoCreateKeyResponses = {
    /**
     * DeployKey
     */
    201: DeployKey;
};

export type RepoCreateKeyResponse = RepoCreateKeyResponses[keyof RepoCreateKeyResponses];

export type RepoDeleteKeyData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the key to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/keys/{id}';
};

export type RepoDeleteKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteKeyError = RepoDeleteKeyErrors[keyof RepoDeleteKeyErrors];

export type RepoDeleteKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetKeyData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the key to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/keys/{id}';
};

export type RepoGetKeyErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetKeyError = RepoGetKeyErrors[keyof RepoGetKeyErrors];

export type RepoGetKeyResponses = {
    /**
     * DeployKey
     */
    200: DeployKey;
};

export type RepoGetKeyResponse = RepoGetKeyResponses[keyof RepoGetKeyResponses];

export type IssueListLabelsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/labels';
};

export type IssueListLabelsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueListLabelsError = IssueListLabelsErrors[keyof IssueListLabelsErrors];

export type IssueListLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueListLabelsResponse = IssueListLabelsResponses[keyof IssueListLabelsResponses];

export type IssueCreateLabelData = {
    body?: CreateLabelOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels';
};

export type IssueCreateLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type IssueCreateLabelError = IssueCreateLabelErrors[keyof IssueCreateLabelErrors];

export type IssueCreateLabelResponses = {
    /**
     * Label
     */
    201: Label;
};

export type IssueCreateLabelResponse = IssueCreateLabelResponses[keyof IssueCreateLabelResponses];

export type IssueDeleteLabelData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the label to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels/{id}';
};

export type IssueDeleteLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteLabelError = IssueDeleteLabelErrors[keyof IssueDeleteLabelErrors];

export type IssueDeleteLabelResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetLabelData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the label to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels/{id}';
};

export type IssueGetLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetLabelError = IssueGetLabelErrors[keyof IssueGetLabelErrors];

export type IssueGetLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type IssueGetLabelResponse = IssueGetLabelResponses[keyof IssueGetLabelResponses];

export type IssueEditLabelData = {
    body?: EditLabelOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the label to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels/{id}';
};

export type IssueEditLabelErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type IssueEditLabelError = IssueEditLabelErrors[keyof IssueEditLabelErrors];

export type IssueEditLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type IssueEditLabelResponse = IssueEditLabelResponses[keyof IssueEditLabelResponses];

export type RepoGetLanguagesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/languages';
};

export type RepoGetLanguagesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetLanguagesError = RepoGetLanguagesErrors[keyof RepoGetLanguagesErrors];

export type RepoGetLanguagesResponses = {
    /**
     * LanguageStatistics
     */
    200: {
        [key: string]: number;
    };
};

export type RepoGetLanguagesResponse = RepoGetLanguagesResponses[keyof RepoGetLanguagesResponses];

export type RepoGetRawFileOrLfsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * filepath of the file to get
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/media/{filepath}';
};

export type RepoGetRawFileOrLfsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetRawFileOrLfsError = RepoGetRawFileOrLfsErrors[keyof RepoGetRawFileOrLfsErrors];

export type RepoGetRawFileOrLfsResponses = {
    /**
     * Returns raw file content.
     */
    200: unknown;
};

export type IssueGetMilestonesListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * Milestone state, Recognized values are open, closed and all. Defaults to "open"
         */
        state?: string;
        /**
         * filter by milestone name
         */
        name?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/milestones';
};

export type IssueGetMilestonesListErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetMilestonesListError = IssueGetMilestonesListErrors[keyof IssueGetMilestonesListErrors];

export type IssueGetMilestonesListResponses = {
    /**
     * MilestoneList
     */
    200: Array<Milestone>;
};

export type IssueGetMilestonesListResponse = IssueGetMilestonesListResponses[keyof IssueGetMilestonesListResponses];

export type IssueCreateMilestoneData = {
    body?: CreateMilestoneOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones';
};

export type IssueCreateMilestoneErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueCreateMilestoneError = IssueCreateMilestoneErrors[keyof IssueCreateMilestoneErrors];

export type IssueCreateMilestoneResponses = {
    /**
     * Milestone
     */
    201: Milestone;
};

export type IssueCreateMilestoneResponse = IssueCreateMilestoneResponses[keyof IssueCreateMilestoneResponses];

export type IssueDeleteMilestoneData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the milestone to delete, identified by ID and if not available by name
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones/{id}';
};

export type IssueDeleteMilestoneErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueDeleteMilestoneError = IssueDeleteMilestoneErrors[keyof IssueDeleteMilestoneErrors];

export type IssueDeleteMilestoneResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetMilestoneData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the milestone to get, identified by ID and if not available by name
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones/{id}';
};

export type IssueGetMilestoneErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueGetMilestoneError = IssueGetMilestoneErrors[keyof IssueGetMilestoneErrors];

export type IssueGetMilestoneResponses = {
    /**
     * Milestone
     */
    200: Milestone;
};

export type IssueGetMilestoneResponse = IssueGetMilestoneResponses[keyof IssueGetMilestoneResponses];

export type IssueEditMilestoneData = {
    body?: EditMilestoneOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the milestone to edit, identified by ID and if not available by name
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones/{id}';
};

export type IssueEditMilestoneErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type IssueEditMilestoneError = IssueEditMilestoneErrors[keyof IssueEditMilestoneErrors];

export type IssueEditMilestoneResponses = {
    /**
     * Milestone
     */
    200: Milestone;
};

export type IssueEditMilestoneResponse = IssueEditMilestoneResponses[keyof IssueEditMilestoneResponses];

export type RepoMirrorSyncData = {
    body?: never;
    path: {
        /**
         * owner of the repo to sync
         */
        owner: string;
        /**
         * name of the repo to sync
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/mirror-sync';
};

export type RepoMirrorSyncErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
};

export type RepoMirrorSyncError = RepoMirrorSyncErrors[keyof RepoMirrorSyncErrors];

export type RepoMirrorSyncResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoNewPinAllowedData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/new_pin_allowed';
};

export type RepoNewPinAllowedErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoNewPinAllowedError = RepoNewPinAllowedErrors[keyof RepoNewPinAllowedErrors];

export type RepoNewPinAllowedResponses = {
    /**
     * RepoNewIssuePinsAllowed
     */
    200: NewIssuePinsAllowed;
};

export type RepoNewPinAllowedResponse = RepoNewPinAllowedResponses[keyof RepoNewPinAllowedResponses];

export type NotifyGetRepoListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * If true, show notifications marked as read. Default value is false
         */
        all?: boolean;
        /**
         * Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned
         */
        'status-types'?: Array<string>;
        /**
         * filter notifications by subject type
         */
        'subject-type'?: Array<'issue' | 'pull' | 'commit' | 'repository'>;
        /**
         * Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/notifications';
};

export type NotifyGetRepoListResponses = {
    /**
     * NotificationThreadList
     */
    200: Array<NotificationThread>;
};

export type NotifyGetRepoListResponse = NotifyGetRepoListResponses[keyof NotifyGetRepoListResponses];

export type NotifyReadRepoListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * If true, mark all notifications on this repo. Default value is false
         */
        all?: string;
        /**
         * Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         */
        'status-types'?: Array<string>;
        /**
         * Status to mark notifications as. Defaults to read.
         */
        'to-status'?: string;
        /**
         * Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         */
        last_read_at?: string;
    };
    url: '/repos/{owner}/{repo}/notifications';
};

export type NotifyReadRepoListResponses = {
    /**
     * NotificationThreadList
     */
    205: Array<NotificationThread>;
};

export type NotifyReadRepoListResponse = NotifyReadRepoListResponses[keyof NotifyReadRepoListResponses];

export type RepoListPullRequestsData = {
    body?: never;
    path: {
        /**
         * Owner of the repo
         */
        owner: string;
        /**
         * Name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * State of pull request
         */
        state?: 'open' | 'closed' | 'all';
        /**
         * Type of sort
         */
        sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority';
        /**
         * ID of the milestone
         */
        milestone?: number;
        /**
         * Label IDs
         */
        labels?: Array<number>;
        /**
         * Filter by pull request author
         */
        poster?: string;
        /**
         * Page number of results to return (1-based)
         */
        page?: number;
        /**
         * Page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/pulls';
};

export type RepoListPullRequestsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    500: ApiError;
};

export type RepoListPullRequestsError = RepoListPullRequestsErrors[keyof RepoListPullRequestsErrors];

export type RepoListPullRequestsResponses = {
    /**
     * PullRequestList
     */
    200: Array<PullRequest>;
};

export type RepoListPullRequestsResponse = RepoListPullRequestsResponses[keyof RepoListPullRequestsResponses];

export type RepoCreatePullRequestData = {
    body?: CreatePullRequestOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls';
};

export type RepoCreatePullRequestErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreatePullRequestError = RepoCreatePullRequestErrors[keyof RepoCreatePullRequestErrors];

export type RepoCreatePullRequestResponses = {
    /**
     * PullRequest
     */
    201: PullRequest;
};

export type RepoCreatePullRequestResponse = RepoCreatePullRequestResponses[keyof RepoCreatePullRequestResponses];

export type RepoListPinnedPullRequestsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/pinned';
};

export type RepoListPinnedPullRequestsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListPinnedPullRequestsError = RepoListPinnedPullRequestsErrors[keyof RepoListPinnedPullRequestsErrors];

export type RepoListPinnedPullRequestsResponses = {
    /**
     * PullRequestList
     */
    200: Array<PullRequest>;
};

export type RepoListPinnedPullRequestsResponse = RepoListPinnedPullRequestsResponses[keyof RepoListPinnedPullRequestsResponses];

export type RepoGetPullRequestByBaseHeadData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * base of the pull request to get
         */
        base: string;
        /**
         * head of the pull request to get
         */
        head: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{base}/{head}';
};

export type RepoGetPullRequestByBaseHeadErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullRequestByBaseHeadError = RepoGetPullRequestByBaseHeadErrors[keyof RepoGetPullRequestByBaseHeadErrors];

export type RepoGetPullRequestByBaseHeadResponses = {
    /**
     * PullRequest
     */
    200: PullRequest;
};

export type RepoGetPullRequestByBaseHeadResponse = RepoGetPullRequestByBaseHeadResponses[keyof RepoGetPullRequestByBaseHeadResponses];

export type RepoGetPullRequestData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}';
};

export type RepoGetPullRequestErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullRequestError = RepoGetPullRequestErrors[keyof RepoGetPullRequestErrors];

export type RepoGetPullRequestResponses = {
    /**
     * PullRequest
     */
    200: PullRequest;
};

export type RepoGetPullRequestResponse = RepoGetPullRequestResponses[keyof RepoGetPullRequestResponses];

export type RepoEditPullRequestData = {
    body?: EditPullRequestOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to edit
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}';
};

export type RepoEditPullRequestErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIError is error format response
     */
    412: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoEditPullRequestError = RepoEditPullRequestErrors[keyof RepoEditPullRequestErrors];

export type RepoEditPullRequestResponses = {
    /**
     * PullRequest
     */
    201: PullRequest;
};

export type RepoEditPullRequestResponse = RepoEditPullRequestResponses[keyof RepoEditPullRequestResponses];

export type RepoDownloadPullDiffOrPatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
        /**
         * whether the output is diff or patch
         */
        diffType: 'diff' | 'patch';
    };
    query?: {
        /**
         * whether to include binary file changes. if true, the diff is applicable with `git apply`
         */
        binary?: boolean;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}.{diffType}';
};

export type RepoDownloadPullDiffOrPatchErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDownloadPullDiffOrPatchError = RepoDownloadPullDiffOrPatchErrors[keyof RepoDownloadPullDiffOrPatchErrors];

export type RepoDownloadPullDiffOrPatchResponses = {
    /**
     * APIString is a string response
     */
    200: string;
};

export type RepoDownloadPullDiffOrPatchResponse = RepoDownloadPullDiffOrPatchResponses[keyof RepoDownloadPullDiffOrPatchResponses];

export type RepoGetPullRequestCommitsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/commits';
};

export type RepoGetPullRequestCommitsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullRequestCommitsError = RepoGetPullRequestCommitsErrors[keyof RepoGetPullRequestCommitsErrors];

export type RepoGetPullRequestCommitsResponses = {
    /**
     * CommitList
     */
    200: Array<Commit>;
};

export type RepoGetPullRequestCommitsResponse = RepoGetPullRequestCommitsResponses[keyof RepoGetPullRequestCommitsResponses];

export type RepoGetPullRequestFilesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: {
        /**
         * skip to given file
         */
        'skip-to'?: string;
        /**
         * whitespace behavior
         */
        whitespace?: 'ignore-all' | 'ignore-change' | 'ignore-eol' | 'show-all';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/files';
};

export type RepoGetPullRequestFilesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullRequestFilesError = RepoGetPullRequestFilesErrors[keyof RepoGetPullRequestFilesErrors];

export type RepoGetPullRequestFilesResponses = {
    /**
     * ChangedFileList
     */
    200: Array<ChangedFile>;
};

export type RepoGetPullRequestFilesResponse = RepoGetPullRequestFilesResponses[keyof RepoGetPullRequestFilesResponses];

export type RepoCancelScheduledAutoMergeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to merge
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/merge';
};

export type RepoCancelScheduledAutoMergeErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCancelScheduledAutoMergeError = RepoCancelScheduledAutoMergeErrors[keyof RepoCancelScheduledAutoMergeErrors];

export type RepoCancelScheduledAutoMergeResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoPullRequestIsMergedData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/merge';
};

export type RepoPullRequestIsMergedErrors = {
    /**
     * pull request has not been merged
     */
    404: unknown;
};

export type RepoPullRequestIsMergedResponses = {
    /**
     * pull request has been merged
     */
    204: unknown;
};

export type RepoMergePullRequestData = {
    body?: MergePullRequestOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to merge
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/merge';
};

export type RepoMergePullRequestErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIEmpty is an empty response
     */
    405: unknown;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoMergePullRequestError = RepoMergePullRequestErrors[keyof RepoMergePullRequestErrors];

export type RepoMergePullRequestResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoDeletePullReviewRequestsData = {
    body: PullReviewRequestOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers';
};

export type RepoDeletePullReviewRequestsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoDeletePullReviewRequestsError = RepoDeletePullReviewRequestsErrors[keyof RepoDeletePullReviewRequestsErrors];

export type RepoDeletePullReviewRequestsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCreatePullReviewRequestsData = {
    body: PullReviewRequestOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers';
};

export type RepoCreatePullReviewRequestsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoCreatePullReviewRequestsError = RepoCreatePullReviewRequestsErrors[keyof RepoCreatePullReviewRequestsErrors];

export type RepoCreatePullReviewRequestsResponses = {
    /**
     * PullReviewList
     */
    201: Array<PullReview>;
};

export type RepoCreatePullReviewRequestsResponse = RepoCreatePullReviewRequestsResponses[keyof RepoCreatePullReviewRequestsResponses];

export type RepoListPullReviewsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews';
};

export type RepoListPullReviewsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListPullReviewsError = RepoListPullReviewsErrors[keyof RepoListPullReviewsErrors];

export type RepoListPullReviewsResponses = {
    /**
     * PullReviewList
     */
    200: Array<PullReview>;
};

export type RepoListPullReviewsResponse = RepoListPullReviewsResponses[keyof RepoListPullReviewsResponses];

export type RepoCreatePullReviewData = {
    body: CreatePullReviewOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews';
};

export type RepoCreatePullReviewErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoCreatePullReviewError = RepoCreatePullReviewErrors[keyof RepoCreatePullReviewErrors];

export type RepoCreatePullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoCreatePullReviewResponse = RepoCreatePullReviewResponses[keyof RepoCreatePullReviewResponses];

export type RepoDeletePullReviewData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}';
};

export type RepoDeletePullReviewErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeletePullReviewError = RepoDeletePullReviewErrors[keyof RepoDeletePullReviewErrors];

export type RepoDeletePullReviewResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetPullReviewData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}';
};

export type RepoGetPullReviewErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullReviewError = RepoGetPullReviewErrors[keyof RepoGetPullReviewErrors];

export type RepoGetPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoGetPullReviewResponse = RepoGetPullReviewResponses[keyof RepoGetPullReviewResponses];

export type RepoSubmitPullReviewData = {
    body: SubmitPullReviewOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}';
};

export type RepoSubmitPullReviewErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoSubmitPullReviewError = RepoSubmitPullReviewErrors[keyof RepoSubmitPullReviewErrors];

export type RepoSubmitPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoSubmitPullReviewResponse = RepoSubmitPullReviewResponses[keyof RepoSubmitPullReviewResponses];

export type RepoGetPullReviewCommentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments';
};

export type RepoGetPullReviewCommentsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullReviewCommentsError = RepoGetPullReviewCommentsErrors[keyof RepoGetPullReviewCommentsErrors];

export type RepoGetPullReviewCommentsResponses = {
    /**
     * PullCommentList
     */
    200: Array<PullReviewComment>;
};

export type RepoGetPullReviewCommentsResponse = RepoGetPullReviewCommentsResponses[keyof RepoGetPullReviewCommentsResponses];

export type RepoCreatePullReviewCommentData = {
    body: CreatePullReviewComment;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments';
};

export type RepoCreatePullReviewCommentErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoCreatePullReviewCommentError = RepoCreatePullReviewCommentErrors[keyof RepoCreatePullReviewCommentErrors];

export type RepoCreatePullReviewCommentResponses = {
    /**
     * PullComment
     */
    200: PullReviewComment;
};

export type RepoCreatePullReviewCommentResponse = RepoCreatePullReviewCommentResponses[keyof RepoCreatePullReviewCommentResponses];

export type RepoDeletePullReviewCommentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
        /**
         * id of the comment
         */
        comment: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments/{comment}';
};

export type RepoDeletePullReviewCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeletePullReviewCommentError = RepoDeletePullReviewCommentErrors[keyof RepoDeletePullReviewCommentErrors];

export type RepoDeletePullReviewCommentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetPullReviewCommentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
        /**
         * id of the comment
         */
        comment: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments/{comment}';
};

export type RepoGetPullReviewCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPullReviewCommentError = RepoGetPullReviewCommentErrors[keyof RepoGetPullReviewCommentErrors];

export type RepoGetPullReviewCommentResponses = {
    /**
     * PullComment
     */
    200: PullReviewComment;
};

export type RepoGetPullReviewCommentResponse = RepoGetPullReviewCommentResponses[keyof RepoGetPullReviewCommentResponses];

export type RepoDismissPullReviewData = {
    body: DismissPullReviewOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals';
};

export type RepoDismissPullReviewErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoDismissPullReviewError = RepoDismissPullReviewErrors[keyof RepoDismissPullReviewErrors];

export type RepoDismissPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoDismissPullReviewResponse = RepoDismissPullReviewResponses[keyof RepoDismissPullReviewResponses];

export type RepoUnDismissPullReviewData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals';
};

export type RepoUnDismissPullReviewErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoUnDismissPullReviewError = RepoUnDismissPullReviewErrors[keyof RepoUnDismissPullReviewErrors];

export type RepoUnDismissPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoUnDismissPullReviewResponse = RepoUnDismissPullReviewResponses[keyof RepoUnDismissPullReviewResponses];

export type RepoUpdatePullRequestData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: {
        /**
         * how to update pull request
         */
        style?: 'merge' | 'rebase';
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/update';
};

export type RepoUpdatePullRequestErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoUpdatePullRequestError = RepoUpdatePullRequestErrors[keyof RepoUpdatePullRequestErrors];

export type RepoUpdatePullRequestResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoListPushMirrorsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/push_mirrors';
};

export type RepoListPushMirrorsErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListPushMirrorsError = RepoListPushMirrorsErrors[keyof RepoListPushMirrorsErrors];

export type RepoListPushMirrorsResponses = {
    /**
     * PushMirrorList
     */
    200: Array<PushMirror>;
};

export type RepoListPushMirrorsResponse = RepoListPushMirrorsResponses[keyof RepoListPushMirrorsResponses];

export type RepoAddPushMirrorData = {
    body?: CreatePushMirrorOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors';
};

export type RepoAddPushMirrorErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
};

export type RepoAddPushMirrorError = RepoAddPushMirrorErrors[keyof RepoAddPushMirrorErrors];

export type RepoAddPushMirrorResponses = {
    /**
     * PushMirror
     */
    200: PushMirror;
};

export type RepoAddPushMirrorResponse = RepoAddPushMirrorResponses[keyof RepoAddPushMirrorResponses];

export type RepoPushMirrorSyncData = {
    body?: never;
    path: {
        /**
         * owner of the repo to sync
         */
        owner: string;
        /**
         * name of the repo to sync
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors-sync';
};

export type RepoPushMirrorSyncErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
};

export type RepoPushMirrorSyncError = RepoPushMirrorSyncErrors[keyof RepoPushMirrorSyncErrors];

export type RepoPushMirrorSyncResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoDeletePushMirrorData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * remote name of the pushMirror
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors/{name}';
};

export type RepoDeletePushMirrorErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeletePushMirrorError = RepoDeletePushMirrorErrors[keyof RepoDeletePushMirrorErrors];

export type RepoDeletePushMirrorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetPushMirrorByRemoteNameData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * remote name of push mirror
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors/{name}';
};

export type RepoGetPushMirrorByRemoteNameErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetPushMirrorByRemoteNameError = RepoGetPushMirrorByRemoteNameErrors[keyof RepoGetPushMirrorByRemoteNameErrors];

export type RepoGetPushMirrorByRemoteNameResponses = {
    /**
     * PushMirror
     */
    200: PushMirror;
};

export type RepoGetPushMirrorByRemoteNameResponse = RepoGetPushMirrorByRemoteNameResponses[keyof RepoGetPushMirrorByRemoteNameResponses];

export type RepoGetRawFileData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * filepath of the file to get
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/raw/{filepath}';
};

export type RepoGetRawFileErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetRawFileError = RepoGetRawFileErrors[keyof RepoGetRawFileErrors];

export type RepoGetRawFileResponses = {
    /**
     * Returns raw file content.
     */
    200: unknown;
};

export type RepoListReleasesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * filter (exclude / include) drafts, if you dont have repo write access none will show
         */
        draft?: boolean;
        /**
         * filter (exclude / include) pre-releases
         */
        'pre-release'?: boolean;
        /**
         * Search string
         */
        q?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/releases';
};

export type RepoListReleasesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListReleasesError = RepoListReleasesErrors[keyof RepoListReleasesErrors];

export type RepoListReleasesResponses = {
    /**
     * ReleaseList
     */
    200: Array<Release>;
};

export type RepoListReleasesResponse = RepoListReleasesResponses[keyof RepoListReleasesResponses];

export type RepoCreateReleaseData = {
    body?: CreateReleaseOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases';
};

export type RepoCreateReleaseErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    409: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoCreateReleaseError = RepoCreateReleaseErrors[keyof RepoCreateReleaseErrors];

export type RepoCreateReleaseResponses = {
    /**
     * Release
     */
    201: Release;
};

export type RepoCreateReleaseResponse = RepoCreateReleaseResponses[keyof RepoCreateReleaseResponses];

export type RepoGetLatestReleaseData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/latest';
};

export type RepoGetLatestReleaseErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetLatestReleaseError = RepoGetLatestReleaseErrors[keyof RepoGetLatestReleaseErrors];

export type RepoGetLatestReleaseResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoGetLatestReleaseResponse = RepoGetLatestReleaseResponses[keyof RepoGetLatestReleaseResponses];

export type RepoDeleteReleaseByTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * tag name of the release to delete
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/tags/{tag}';
};

export type RepoDeleteReleaseByTagErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoDeleteReleaseByTagError = RepoDeleteReleaseByTagErrors[keyof RepoDeleteReleaseByTagErrors];

export type RepoDeleteReleaseByTagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetReleaseByTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * tag name of the release to get
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/tags/{tag}';
};

export type RepoGetReleaseByTagErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetReleaseByTagError = RepoGetReleaseByTagErrors[keyof RepoGetReleaseByTagErrors];

export type RepoGetReleaseByTagResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoGetReleaseByTagResponse = RepoGetReleaseByTagResponses[keyof RepoGetReleaseByTagResponses];

export type RepoDeleteReleaseData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}';
};

export type RepoDeleteReleaseErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoDeleteReleaseError = RepoDeleteReleaseErrors[keyof RepoDeleteReleaseErrors];

export type RepoDeleteReleaseResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetReleaseData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}';
};

export type RepoGetReleaseErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetReleaseError = RepoGetReleaseErrors[keyof RepoGetReleaseErrors];

export type RepoGetReleaseResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoGetReleaseResponse = RepoGetReleaseResponses[keyof RepoGetReleaseResponses];

export type RepoEditReleaseData = {
    body?: EditReleaseOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}';
};

export type RepoEditReleaseErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoEditReleaseError = RepoEditReleaseErrors[keyof RepoEditReleaseErrors];

export type RepoEditReleaseResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoEditReleaseResponse = RepoEditReleaseResponses[keyof RepoEditReleaseResponses];

export type RepoListReleaseAttachmentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets';
};

export type RepoListReleaseAttachmentsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListReleaseAttachmentsError = RepoListReleaseAttachmentsErrors[keyof RepoListReleaseAttachmentsErrors];

export type RepoListReleaseAttachmentsResponses = {
    /**
     * AttachmentList
     */
    200: Array<Attachment>;
};

export type RepoListReleaseAttachmentsResponse = RepoListReleaseAttachmentsResponses[keyof RepoListReleaseAttachmentsResponses];

export type RepoCreateReleaseAttachmentData = {
    body?: {
        /**
         * attachment to upload (this parameter is incompatible with `external_url`)
         */
        attachment?: Blob | File;
        /**
         * url to external asset (this parameter is incompatible with `attachment`)
         */
        external_url?: string;
    };
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
    };
    query?: {
        /**
         * name of the attachment
         */
        name?: string;
    };
    url: '/repos/{owner}/{repo}/releases/{id}/assets';
};

export type RepoCreateReleaseAttachmentErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
};

export type RepoCreateReleaseAttachmentError = RepoCreateReleaseAttachmentErrors[keyof RepoCreateReleaseAttachmentErrors];

export type RepoCreateReleaseAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type RepoCreateReleaseAttachmentResponse = RepoCreateReleaseAttachmentResponses[keyof RepoCreateReleaseAttachmentResponses];

export type RepoDeleteReleaseAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
        /**
         * id of the attachment to delete
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}';
};

export type RepoDeleteReleaseAttachmentErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteReleaseAttachmentError = RepoDeleteReleaseAttachmentErrors[keyof RepoDeleteReleaseAttachmentErrors];

export type RepoDeleteReleaseAttachmentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetReleaseAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
        /**
         * id of the attachment to get
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}';
};

export type RepoGetReleaseAttachmentErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetReleaseAttachmentError = RepoGetReleaseAttachmentErrors[keyof RepoGetReleaseAttachmentErrors];

export type RepoGetReleaseAttachmentResponses = {
    /**
     * Attachment
     */
    200: Attachment;
};

export type RepoGetReleaseAttachmentResponse = RepoGetReleaseAttachmentResponses[keyof RepoGetReleaseAttachmentResponses];

export type RepoEditReleaseAttachmentData = {
    body?: EditAttachmentOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
        /**
         * id of the attachment to edit
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}';
};

export type RepoEditReleaseAttachmentErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
};

export type RepoEditReleaseAttachmentError = RepoEditReleaseAttachmentErrors[keyof RepoEditReleaseAttachmentErrors];

export type RepoEditReleaseAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type RepoEditReleaseAttachmentResponse = RepoEditReleaseAttachmentResponses[keyof RepoEditReleaseAttachmentResponses];

export type RepoGetReviewersData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/reviewers';
};

export type RepoGetReviewersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetReviewersError = RepoGetReviewersErrors[keyof RepoGetReviewersErrors];

export type RepoGetReviewersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoGetReviewersResponse = RepoGetReviewersResponses[keyof RepoGetReviewersResponses];

export type RepoSigningKeyData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/signing-key.gpg';
};

export type RepoSigningKeyResponses = {
    /**
     * GPG armored public key
     */
    200: string;
};

export type RepoSigningKeyResponse = RepoSigningKeyResponses[keyof RepoSigningKeyResponses];

export type RepoListStargazersData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/stargazers';
};

export type RepoListStargazersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListStargazersError = RepoListStargazersErrors[keyof RepoListStargazersErrors];

export type RepoListStargazersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoListStargazersResponse = RepoListStargazersResponses[keyof RepoListStargazersResponses];

export type RepoListStatusesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: {
        /**
         * type of sort
         */
        sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex';
        /**
         * type of state
         */
        state?: 'pending' | 'success' | 'error' | 'failure' | 'warning';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/statuses/{sha}';
};

export type RepoListStatusesErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListStatusesError = RepoListStatusesErrors[keyof RepoListStatusesErrors];

export type RepoListStatusesResponses = {
    /**
     * CommitStatusList
     */
    200: Array<CommitStatus>;
};

export type RepoListStatusesResponse = RepoListStatusesResponses[keyof RepoListStatusesResponses];

export type RepoCreateStatusData = {
    body?: CreateStatusOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/statuses/{sha}';
};

export type RepoCreateStatusErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoCreateStatusError = RepoCreateStatusErrors[keyof RepoCreateStatusErrors];

export type RepoCreateStatusResponses = {
    /**
     * CommitStatus
     */
    201: CommitStatus;
};

export type RepoCreateStatusResponse = RepoCreateStatusResponses[keyof RepoCreateStatusResponses];

export type RepoListSubscribersData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/subscribers';
};

export type RepoListSubscribersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListSubscribersError = RepoListSubscribersErrors[keyof RepoListSubscribersErrors];

export type RepoListSubscribersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoListSubscribersResponse = RepoListSubscribersResponses[keyof RepoListSubscribersResponses];

export type UserCurrentDeleteSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/subscription';
};

export type UserCurrentDeleteSubscriptionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentDeleteSubscriptionError = UserCurrentDeleteSubscriptionErrors[keyof UserCurrentDeleteSubscriptionErrors];

export type UserCurrentDeleteSubscriptionResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentCheckSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/subscription';
};

export type UserCurrentCheckSubscriptionErrors = {
    /**
     * User is not watching this repo or repo do not exist
     */
    404: unknown;
};

export type UserCurrentCheckSubscriptionResponses = {
    /**
     * WatchInfo
     */
    200: WatchInfo;
};

export type UserCurrentCheckSubscriptionResponse = UserCurrentCheckSubscriptionResponses[keyof UserCurrentCheckSubscriptionResponses];

export type UserCurrentPutSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/subscription';
};

export type UserCurrentPutSubscriptionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentPutSubscriptionError = UserCurrentPutSubscriptionErrors[keyof UserCurrentPutSubscriptionErrors];

export type UserCurrentPutSubscriptionResponses = {
    /**
     * WatchInfo
     */
    200: WatchInfo;
};

export type UserCurrentPutSubscriptionResponse = UserCurrentPutSubscriptionResponses[keyof UserCurrentPutSubscriptionResponses];

export type RepoListTagProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections';
};

export type RepoListTagProtectionResponses = {
    /**
     * TagProtectionList
     */
    200: Array<TagProtection>;
};

export type RepoListTagProtectionResponse = RepoListTagProtectionResponses[keyof RepoListTagProtectionResponses];

export type RepoCreateTagProtectionData = {
    body?: CreateTagProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections';
};

export type RepoCreateTagProtectionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreateTagProtectionError = RepoCreateTagProtectionErrors[keyof RepoCreateTagProtectionErrors];

export type RepoCreateTagProtectionResponses = {
    /**
     * TagProtection
     */
    201: TagProtection;
};

export type RepoCreateTagProtectionResponse = RepoCreateTagProtectionResponses[keyof RepoCreateTagProtectionResponses];

export type RepoDeleteTagProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of protected tag
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections/{id}';
};

export type RepoDeleteTagProtectionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoDeleteTagProtectionError = RepoDeleteTagProtectionErrors[keyof RepoDeleteTagProtectionErrors];

export type RepoDeleteTagProtectionResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetTagProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the tag protect to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections/{id}';
};

export type RepoGetTagProtectionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetTagProtectionError = RepoGetTagProtectionErrors[keyof RepoGetTagProtectionErrors];

export type RepoGetTagProtectionResponses = {
    /**
     * TagProtection
     */
    200: TagProtection;
};

export type RepoGetTagProtectionResponse = RepoGetTagProtectionResponses[keyof RepoGetTagProtectionResponses];

export type RepoEditTagProtectionData = {
    body?: EditTagProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of protected tag
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections/{id}';
};

export type RepoEditTagProtectionErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoEditTagProtectionError = RepoEditTagProtectionErrors[keyof RepoEditTagProtectionErrors];

export type RepoEditTagProtectionResponses = {
    /**
     * TagProtection
     */
    200: TagProtection;
};

export type RepoEditTagProtectionResponse = RepoEditTagProtectionResponses[keyof RepoEditTagProtectionResponses];

export type RepoListTagsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results, default maximum page size is 50
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/tags';
};

export type RepoListTagsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListTagsError = RepoListTagsErrors[keyof RepoListTagsErrors];

export type RepoListTagsResponses = {
    /**
     * TagList
     */
    200: Array<Tag>;
};

export type RepoListTagsResponse = RepoListTagsResponses[keyof RepoListTagsResponses];

export type RepoCreateTagData = {
    body?: CreateTagOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tags';
};

export type RepoCreateTagErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIEmpty is an empty response
     */
    405: unknown;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreateTagError = RepoCreateTagErrors[keyof RepoCreateTagErrors];

export type RepoCreateTagResponses = {
    /**
     * Tag
     */
    201: Tag;
};

export type RepoCreateTagResponse = RepoCreateTagResponses[keyof RepoCreateTagResponses];

export type RepoDeleteTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of tag to delete
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tags/{tag}';
};

export type RepoDeleteTagErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIEmpty is an empty response
     */
    405: unknown;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoDeleteTagError = RepoDeleteTagErrors[keyof RepoDeleteTagErrors];

export type RepoDeleteTagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of tag
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tags/{tag}';
};

export type RepoGetTagErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetTagError = RepoGetTagErrors[keyof RepoGetTagErrors];

export type RepoGetTagResponses = {
    /**
     * Tag
     */
    200: Tag;
};

export type RepoGetTagResponse = RepoGetTagResponses[keyof RepoGetTagResponses];

export type RepoListTeamsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams';
};

export type RepoListTeamsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListTeamsError = RepoListTeamsErrors[keyof RepoListTeamsErrors];

export type RepoListTeamsResponses = {
    /**
     * TeamList
     */
    200: Array<Team>;
};

export type RepoListTeamsResponse = RepoListTeamsResponses[keyof RepoListTeamsResponses];

export type RepoDeleteTeamData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * team name
         */
        team: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams/{team}';
};

export type RepoDeleteTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    405: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoDeleteTeamError = RepoDeleteTeamErrors[keyof RepoDeleteTeamErrors];

export type RepoDeleteTeamResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCheckTeamData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * team name
         */
        team: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams/{team}';
};

export type RepoCheckTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    405: ApiError;
};

export type RepoCheckTeamError = RepoCheckTeamErrors[keyof RepoCheckTeamErrors];

export type RepoCheckTeamResponses = {
    /**
     * Team
     */
    200: Team;
};

export type RepoCheckTeamResponse = RepoCheckTeamResponses[keyof RepoCheckTeamResponses];

export type RepoAddTeamData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * team name
         */
        team: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams/{team}';
};

export type RepoAddTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    405: ApiError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoAddTeamError = RepoAddTeamErrors[keyof RepoAddTeamErrors];

export type RepoAddTeamResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoTrackedTimesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * optional filter by user (available for issue managers)
         */
        user?: string;
        /**
         * Only show times updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show times updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/times';
};

export type RepoTrackedTimesErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoTrackedTimesError = RepoTrackedTimesErrors[keyof RepoTrackedTimesErrors];

export type RepoTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type RepoTrackedTimesResponse = RepoTrackedTimesResponses[keyof RepoTrackedTimesResponses];

export type UserTrackedTimesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of user
         */
        user: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/times/{user}';
};

export type UserTrackedTimesErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserTrackedTimesError = UserTrackedTimesErrors[keyof UserTrackedTimesErrors];

export type UserTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type UserTrackedTimesResponse = UserTrackedTimesResponses[keyof UserTrackedTimesResponses];

export type RepoListTopicsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/topics';
};

export type RepoListTopicsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoListTopicsError = RepoListTopicsErrors[keyof RepoListTopicsErrors];

export type RepoListTopicsResponses = {
    /**
     * TopicNames
     */
    200: TopicName;
};

export type RepoListTopicsResponse = RepoListTopicsResponses[keyof RepoListTopicsResponses];

export type RepoUpdateTopicsData = {
    body?: RepoTopicOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/topics';
};

export type RepoUpdateTopicsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIInvalidTopicsError is error format response to invalid topics
     */
    422: ApiInvalidTopicsError;
};

export type RepoUpdateTopicsError = RepoUpdateTopicsErrors[keyof RepoUpdateTopicsErrors];

export type RepoUpdateTopicsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoDeleteTopicData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the topic to delete
         */
        topic: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/topics/{topic}';
};

export type RepoDeleteTopicErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIInvalidTopicsError is error format response to invalid topics
     */
    422: ApiInvalidTopicsError;
};

export type RepoDeleteTopicError = RepoDeleteTopicErrors[keyof RepoDeleteTopicErrors];

export type RepoDeleteTopicResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoAddTopicData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the topic to add
         */
        topic: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/topics/{topic}';
};

export type RepoAddTopicErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIInvalidTopicsError is error format response to invalid topics
     */
    422: ApiInvalidTopicsError;
};

export type RepoAddTopicError = RepoAddTopicErrors[keyof RepoAddTopicErrors];

export type RepoAddTopicResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoTransferData = {
    /**
     * Transfer Options
     */
    body: TransferRepoOption;
    path: {
        /**
         * owner of the repo to transfer
         */
        owner: string;
        /**
         * name of the repo to transfer
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/transfer';
};

export type RepoTransferErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type RepoTransferError = RepoTransferErrors[keyof RepoTransferErrors];

export type RepoTransferResponses = {
    /**
     * Repository
     */
    202: Repository;
};

export type RepoTransferResponse = RepoTransferResponses[keyof RepoTransferResponses];

export type AcceptRepoTransferData = {
    body?: never;
    path: {
        /**
         * owner of the repo to transfer
         */
        owner: string;
        /**
         * name of the repo to transfer
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/transfer/accept';
};

export type AcceptRepoTransferErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
};

export type AcceptRepoTransferError = AcceptRepoTransferErrors[keyof AcceptRepoTransferErrors];

export type AcceptRepoTransferResponses = {
    /**
     * Repository
     */
    202: Repository;
};

export type AcceptRepoTransferResponse = AcceptRepoTransferResponses[keyof AcceptRepoTransferResponses];

export type RejectRepoTransferData = {
    body?: never;
    path: {
        /**
         * owner of the repo to transfer
         */
        owner: string;
        /**
         * name of the repo to transfer
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/transfer/reject';
};

export type RejectRepoTransferErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RejectRepoTransferError = RejectRepoTransferErrors[keyof RejectRepoTransferErrors];

export type RejectRepoTransferResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RejectRepoTransferResponse = RejectRepoTransferResponses[keyof RejectRepoTransferResponses];

export type RepoCreateWikiPageData = {
    body?: CreateWikiPageOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/new';
};

export type RepoCreateWikiPageErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoCreateWikiPageError = RepoCreateWikiPageErrors[keyof RepoCreateWikiPageErrors];

export type RepoCreateWikiPageResponses = {
    /**
     * WikiPage
     */
    201: WikiPage;
};

export type RepoCreateWikiPageResponse = RepoCreateWikiPageResponses[keyof RepoCreateWikiPageResponses];

export type RepoDeleteWikiPageData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/page/{pageName}';
};

export type RepoDeleteWikiPageErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoDeleteWikiPageError = RepoDeleteWikiPageErrors[keyof RepoDeleteWikiPageErrors];

export type RepoDeleteWikiPageResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetWikiPageData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/page/{pageName}';
};

export type RepoGetWikiPageErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetWikiPageError = RepoGetWikiPageErrors[keyof RepoGetWikiPageErrors];

export type RepoGetWikiPageResponses = {
    /**
     * WikiPage
     */
    200: WikiPage;
};

export type RepoGetWikiPageResponse = RepoGetWikiPageResponses[keyof RepoGetWikiPageResponses];

export type RepoEditWikiPageData = {
    body?: CreateWikiPageOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/page/{pageName}';
};

export type RepoEditWikiPageErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: ApiRepoArchivedError;
};

export type RepoEditWikiPageError = RepoEditWikiPageErrors[keyof RepoEditWikiPageErrors];

export type RepoEditWikiPageResponses = {
    /**
     * WikiPage
     */
    200: WikiPage;
};

export type RepoEditWikiPageResponse = RepoEditWikiPageResponses[keyof RepoEditWikiPageResponses];

export type RepoGetWikiPagesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/wiki/pages';
};

export type RepoGetWikiPagesErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetWikiPagesError = RepoGetWikiPagesErrors[keyof RepoGetWikiPagesErrors];

export type RepoGetWikiPagesResponses = {
    /**
     * WikiPageList
     */
    200: Array<WikiPageMetaData>;
};

export type RepoGetWikiPagesResponse = RepoGetWikiPagesResponses[keyof RepoGetWikiPagesResponses];

export type RepoGetWikiPageRevisionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
    };
    url: '/repos/{owner}/{repo}/wiki/revisions/{pageName}';
};

export type RepoGetWikiPageRevisionsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetWikiPageRevisionsError = RepoGetWikiPageRevisionsErrors[keyof RepoGetWikiPageRevisionsErrors];

export type RepoGetWikiPageRevisionsResponses = {
    /**
     * WikiCommitList
     */
    200: WikiCommitList;
};

export type RepoGetWikiPageRevisionsResponse = RepoGetWikiPageRevisionsResponses[keyof RepoGetWikiPageRevisionsResponses];

export type GenerateRepoData = {
    body?: GenerateRepoOption;
    path: {
        /**
         * name of the template repository owner
         */
        template_owner: string;
        /**
         * name of the template repository
         */
        template_repo: string;
    };
    query?: never;
    url: '/repos/{template_owner}/{template_repo}/generate';
};

export type GenerateRepoErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type GenerateRepoError = GenerateRepoErrors[keyof GenerateRepoErrors];

export type GenerateRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type GenerateRepoResponse = GenerateRepoResponses[keyof GenerateRepoResponses];

export type RepoGetByIdData = {
    body?: never;
    path: {
        /**
         * id of the repo to get
         */
        id: number;
    };
    query?: never;
    url: '/repositories/{id}';
};

export type RepoGetByIdErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type RepoGetByIdError = RepoGetByIdErrors[keyof RepoGetByIdErrors];

export type RepoGetByIdResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RepoGetByIdResponse = RepoGetByIdResponses[keyof RepoGetByIdResponses];

export type GetGeneralApiSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/api';
};

export type GetGeneralApiSettingsResponses = {
    /**
     * GeneralAPISettings
     */
    200: GeneralApiSettings;
};

export type GetGeneralApiSettingsResponse = GetGeneralApiSettingsResponses[keyof GetGeneralApiSettingsResponses];

export type GetGeneralAttachmentSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/attachment';
};

export type GetGeneralAttachmentSettingsResponses = {
    /**
     * GeneralAttachmentSettings
     */
    200: GeneralAttachmentSettings;
};

export type GetGeneralAttachmentSettingsResponse = GetGeneralAttachmentSettingsResponses[keyof GetGeneralAttachmentSettingsResponses];

export type GetGeneralRepositorySettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/repository';
};

export type GetGeneralRepositorySettingsResponses = {
    /**
     * GeneralRepoSettings
     */
    200: GeneralRepoSettings;
};

export type GetGeneralRepositorySettingsResponse = GetGeneralRepositorySettingsResponses[keyof GetGeneralRepositorySettingsResponses];

export type GetGeneralUiSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/ui';
};

export type GetGeneralUiSettingsResponses = {
    /**
     * GeneralUISettings
     */
    200: GeneralUiSettings;
};

export type GetGeneralUiSettingsResponse = GetGeneralUiSettingsResponses[keyof GetGeneralUiSettingsResponses];

export type GetSigningKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/signing-key.gpg';
};

export type GetSigningKeyResponses = {
    /**
     * GPG armored public key
     */
    200: string;
};

export type GetSigningKeyResponse = GetSigningKeyResponses[keyof GetSigningKeyResponses];

export type OrgDeleteTeamData = {
    body?: never;
    path: {
        /**
         * id of the team to delete
         */
        id: number;
    };
    query?: never;
    url: '/teams/{id}';
};

export type OrgDeleteTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgDeleteTeamError = OrgDeleteTeamErrors[keyof OrgDeleteTeamErrors];

export type OrgDeleteTeamResponses = {
    /**
     * team deleted
     */
    204: unknown;
};

export type OrgGetTeamData = {
    body?: never;
    path: {
        /**
         * id of the team to get
         */
        id: number;
    };
    query?: never;
    url: '/teams/{id}';
};

export type OrgGetTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgGetTeamError = OrgGetTeamErrors[keyof OrgGetTeamErrors];

export type OrgGetTeamResponses = {
    /**
     * Team
     */
    200: Team;
};

export type OrgGetTeamResponse = OrgGetTeamResponses[keyof OrgGetTeamResponses];

export type OrgEditTeamData = {
    body?: EditTeamOption;
    path: {
        /**
         * id of the team to edit
         */
        id: number;
    };
    query?: never;
    url: '/teams/{id}';
};

export type OrgEditTeamErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgEditTeamError = OrgEditTeamErrors[keyof OrgEditTeamErrors];

export type OrgEditTeamResponses = {
    /**
     * Team
     */
    200: Team;
};

export type OrgEditTeamResponse = OrgEditTeamResponses[keyof OrgEditTeamResponses];

export type OrgListTeamActivityFeedsData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
    };
    query?: {
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/teams/{id}/activities/feeds';
};

export type OrgListTeamActivityFeedsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListTeamActivityFeedsError = OrgListTeamActivityFeedsErrors[keyof OrgListTeamActivityFeedsErrors];

export type OrgListTeamActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type OrgListTeamActivityFeedsResponse = OrgListTeamActivityFeedsResponses[keyof OrgListTeamActivityFeedsResponses];

export type OrgListTeamMembersData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/teams/{id}/members';
};

export type OrgListTeamMembersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListTeamMembersError = OrgListTeamMembersErrors[keyof OrgListTeamMembersErrors];

export type OrgListTeamMembersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrgListTeamMembersResponse = OrgListTeamMembersResponses[keyof OrgListTeamMembersResponses];

export type OrgRemoveTeamMemberData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * username of the user to remove
         */
        username: string;
    };
    query?: never;
    url: '/teams/{id}/members/{username}';
};

export type OrgRemoveTeamMemberErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgRemoveTeamMemberError = OrgRemoveTeamMemberErrors[keyof OrgRemoveTeamMemberErrors];

export type OrgRemoveTeamMemberResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListTeamMemberData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * username of the member to list
         */
        username: string;
    };
    query?: never;
    url: '/teams/{id}/members/{username}';
};

export type OrgListTeamMemberErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListTeamMemberError = OrgListTeamMemberErrors[keyof OrgListTeamMemberErrors];

export type OrgListTeamMemberResponses = {
    /**
     * User
     */
    200: User;
};

export type OrgListTeamMemberResponse = OrgListTeamMemberResponses[keyof OrgListTeamMemberResponses];

export type OrgAddTeamMemberData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * username of the user to add
         */
        username: string;
    };
    query?: never;
    url: '/teams/{id}/members/{username}';
};

export type OrgAddTeamMemberErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgAddTeamMemberError = OrgAddTeamMemberErrors[keyof OrgAddTeamMemberErrors];

export type OrgAddTeamMemberResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListTeamReposData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/teams/{id}/repos';
};

export type OrgListTeamReposErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListTeamReposError = OrgListTeamReposErrors[keyof OrgListTeamReposErrors];

export type OrgListTeamReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type OrgListTeamReposResponse = OrgListTeamReposResponses[keyof OrgListTeamReposResponses];

export type OrgRemoveTeamRepositoryData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * organization that owns the repo to remove
         */
        org: string;
        /**
         * name of the repo to remove
         */
        repo: string;
    };
    query?: never;
    url: '/teams/{id}/repos/{org}/{repo}';
};

export type OrgRemoveTeamRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgRemoveTeamRepositoryError = OrgRemoveTeamRepositoryErrors[keyof OrgRemoveTeamRepositoryErrors];

export type OrgRemoveTeamRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListTeamRepoData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * organization that owns the repo to list
         */
        org: string;
        /**
         * name of the repo to list
         */
        repo: string;
    };
    query?: never;
    url: '/teams/{id}/repos/{org}/{repo}';
};

export type OrgListTeamRepoErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListTeamRepoError = OrgListTeamRepoErrors[keyof OrgListTeamRepoErrors];

export type OrgListTeamRepoResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type OrgListTeamRepoResponse = OrgListTeamRepoResponses[keyof OrgListTeamRepoResponses];

export type OrgAddTeamRepositoryData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * organization that owns the repo to add
         */
        org: string;
        /**
         * name of the repo to add
         */
        repo: string;
    };
    query?: never;
    url: '/teams/{id}/repos/{org}/{repo}';
};

export type OrgAddTeamRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgAddTeamRepositoryError = OrgAddTeamRepositoryErrors[keyof OrgAddTeamRepositoryErrors];

export type OrgAddTeamRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type TopicSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * keywords to search
         */
        q: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/topics/search';
};

export type TopicSearchErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type TopicSearchError = TopicSearchErrors[keyof TopicSearchErrors];

export type TopicSearchResponses = {
    /**
     * TopicListResponse
     */
    200: Array<TopicResponse>;
};

export type TopicSearchResponse = TopicSearchResponses[keyof TopicSearchResponses];

export type UserGetCurrentData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type UserGetCurrentErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserGetCurrentError = UserGetCurrentErrors[keyof UserGetCurrentErrors];

export type UserGetCurrentResponses = {
    /**
     * User
     */
    200: User;
};

export type UserGetCurrentResponse = UserGetCurrentResponses[keyof UserGetCurrentResponses];

export type UserSearchRunJobsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * a comma separated list of run job labels to search for
         */
        labels?: string;
    };
    url: '/user/actions/runners/jobs';
};

export type UserSearchRunJobsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserSearchRunJobsError = UserSearchRunJobsErrors[keyof UserSearchRunJobsErrors];

export type UserSearchRunJobsResponses = {
    /**
     * RunJobList is a list of action run jobs
     */
    200: Array<ActionRunJob>;
};

export type UserSearchRunJobsResponse = UserSearchRunJobsResponses[keyof UserSearchRunJobsResponses];

export type UserGetRunnerRegistrationTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/actions/runners/registration-token';
};

export type UserGetRunnerRegistrationTokenErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserGetRunnerRegistrationTokenError = UserGetRunnerRegistrationTokenErrors[keyof UserGetRunnerRegistrationTokenErrors];

export type UserGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is a string used to register a runner with a server
     */
    200: unknown;
};

export type DeleteUserSecretData = {
    body?: never;
    path: {
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/user/actions/secrets/{secretname}';
};

export type DeleteUserSecretErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeleteUserSecretError = DeleteUserSecretErrors[keyof DeleteUserSecretErrors];

export type DeleteUserSecretResponses = {
    /**
     * delete one secret of the user
     */
    204: unknown;
};

export type UpdateUserSecretData = {
    body?: CreateOrUpdateSecretOption;
    path: {
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/user/actions/secrets/{secretname}';
};

export type UpdateUserSecretErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UpdateUserSecretError = UpdateUserSecretErrors[keyof UpdateUserSecretErrors];

export type UpdateUserSecretResponses = {
    /**
     * response when creating a secret
     */
    201: unknown;
    /**
     * response when updating a secret
     */
    204: unknown;
};

export type GetUserVariablesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/actions/variables';
};

export type GetUserVariablesListErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetUserVariablesListError = GetUserVariablesListErrors[keyof GetUserVariablesListErrors];

export type GetUserVariablesListResponses = {
    /**
     * VariableList
     */
    200: Array<ActionVariable>;
};

export type GetUserVariablesListResponse = GetUserVariablesListResponses[keyof GetUserVariablesListResponses];

export type DeleteUserVariableData = {
    body?: never;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type DeleteUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type DeleteUserVariableError = DeleteUserVariableErrors[keyof DeleteUserVariableErrors];

export type DeleteUserVariableResponses = {
    /**
     * response when deleting a variable
     */
    201: unknown;
    /**
     * response when deleting a variable
     */
    204: unknown;
};

export type GetUserVariableData = {
    body?: never;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type GetUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetUserVariableError = GetUserVariableErrors[keyof GetUserVariableErrors];

export type GetUserVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
};

export type GetUserVariableResponse = GetUserVariableResponses[keyof GetUserVariableResponses];

export type CreateUserVariableData = {
    body?: CreateVariableOption;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type CreateUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type CreateUserVariableError = CreateUserVariableErrors[keyof CreateUserVariableErrors];

export type CreateUserVariableResponses = {
    /**
     * response when creating a variable
     */
    201: unknown;
    /**
     * response when creating a variable
     */
    204: unknown;
};

export type UpdateUserVariableData = {
    body?: UpdateVariableOption;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type UpdateUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UpdateUserVariableError = UpdateUserVariableErrors[keyof UpdateUserVariableErrors];

export type UpdateUserVariableResponses = {
    /**
     * response when updating a variable
     */
    201: unknown;
    /**
     * response when updating a variable
     */
    204: unknown;
};

export type UserGetOAuth2ApplicationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/applications/oauth2';
};

export type UserGetOAuth2ApplicationsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserGetOAuth2ApplicationsError = UserGetOAuth2ApplicationsErrors[keyof UserGetOAuth2ApplicationsErrors];

export type UserGetOAuth2ApplicationsResponses = {
    /**
     * OAuth2ApplicationList represents a list of OAuth2 applications.
     */
    200: Array<OAuth2Application>;
};

export type UserGetOAuth2ApplicationsResponse = UserGetOAuth2ApplicationsResponses[keyof UserGetOAuth2ApplicationsResponses];

export type UserCreateOAuth2ApplicationData = {
    body: CreateOAuth2ApplicationOptions;
    path?: never;
    query?: never;
    url: '/user/applications/oauth2';
};

export type UserCreateOAuth2ApplicationErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCreateOAuth2ApplicationError = UserCreateOAuth2ApplicationErrors[keyof UserCreateOAuth2ApplicationErrors];

export type UserCreateOAuth2ApplicationResponses = {
    /**
     * OAuth2Application
     */
    201: OAuth2Application;
};

export type UserCreateOAuth2ApplicationResponse = UserCreateOAuth2ApplicationResponses[keyof UserCreateOAuth2ApplicationResponses];

export type UserDeleteOAuth2ApplicationData = {
    body?: never;
    path: {
        /**
         * token to be deleted
         */
        id: number;
    };
    query?: never;
    url: '/user/applications/oauth2/{id}';
};

export type UserDeleteOAuth2ApplicationErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserDeleteOAuth2ApplicationError = UserDeleteOAuth2ApplicationErrors[keyof UserDeleteOAuth2ApplicationErrors];

export type UserDeleteOAuth2ApplicationResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserGetOAuth2ApplicationData = {
    body?: never;
    path: {
        /**
         * Application ID to be found
         */
        id: number;
    };
    query?: never;
    url: '/user/applications/oauth2/{id}';
};

export type UserGetOAuth2ApplicationErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserGetOAuth2ApplicationError = UserGetOAuth2ApplicationErrors[keyof UserGetOAuth2ApplicationErrors];

export type UserGetOAuth2ApplicationResponses = {
    /**
     * OAuth2Application
     */
    200: OAuth2Application;
};

export type UserGetOAuth2ApplicationResponse = UserGetOAuth2ApplicationResponses[keyof UserGetOAuth2ApplicationResponses];

export type UserUpdateOAuth2ApplicationData = {
    body: CreateOAuth2ApplicationOptions;
    path: {
        /**
         * application to be updated
         */
        id: number;
    };
    query?: never;
    url: '/user/applications/oauth2/{id}';
};

export type UserUpdateOAuth2ApplicationErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserUpdateOAuth2ApplicationError = UserUpdateOAuth2ApplicationErrors[keyof UserUpdateOAuth2ApplicationErrors];

export type UserUpdateOAuth2ApplicationResponses = {
    /**
     * OAuth2Application
     */
    200: OAuth2Application;
};

export type UserUpdateOAuth2ApplicationResponse = UserUpdateOAuth2ApplicationResponses[keyof UserUpdateOAuth2ApplicationResponses];

export type UserDeleteAvatarData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/avatar';
};

export type UserDeleteAvatarErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserDeleteAvatarError = UserDeleteAvatarErrors[keyof UserDeleteAvatarErrors];

export type UserDeleteAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserUpdateAvatarData = {
    body?: UpdateUserAvatarOption;
    path?: never;
    query?: never;
    url: '/user/avatar';
};

export type UserUpdateAvatarErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserUpdateAvatarError = UserUpdateAvatarErrors[keyof UserUpdateAvatarErrors];

export type UserUpdateAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserBlockUserData = {
    body?: never;
    path: {
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/user/block/{username}';
};

export type UserBlockUserErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserBlockUserError = UserBlockUserErrors[keyof UserBlockUserErrors];

export type UserBlockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserDeleteEmailData = {
    body?: DeleteEmailOption;
    path?: never;
    query?: never;
    url: '/user/emails';
};

export type UserDeleteEmailErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserDeleteEmailError = UserDeleteEmailErrors[keyof UserDeleteEmailErrors];

export type UserDeleteEmailResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserListEmailsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/emails';
};

export type UserListEmailsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListEmailsError = UserListEmailsErrors[keyof UserListEmailsErrors];

export type UserListEmailsResponses = {
    /**
     * EmailList
     */
    200: Array<Email>;
};

export type UserListEmailsResponse = UserListEmailsResponses[keyof UserListEmailsResponses];

export type UserAddEmailData = {
    body?: CreateEmailOption;
    path?: never;
    query?: never;
    url: '/user/emails';
};

export type UserAddEmailErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserAddEmailError = UserAddEmailErrors[keyof UserAddEmailErrors];

export type UserAddEmailResponses = {
    /**
     * EmailList
     */
    201: Array<Email>;
};

export type UserAddEmailResponse = UserAddEmailResponses[keyof UserAddEmailResponses];

export type UserCurrentListFollowersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/followers';
};

export type UserCurrentListFollowersErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentListFollowersError = UserCurrentListFollowersErrors[keyof UserCurrentListFollowersErrors];

export type UserCurrentListFollowersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserCurrentListFollowersResponse = UserCurrentListFollowersResponses[keyof UserCurrentListFollowersResponses];

export type UserCurrentListFollowingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/following';
};

export type UserCurrentListFollowingErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentListFollowingError = UserCurrentListFollowingErrors[keyof UserCurrentListFollowingErrors];

export type UserCurrentListFollowingResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserCurrentListFollowingResponse = UserCurrentListFollowingResponses[keyof UserCurrentListFollowingResponses];

export type UserCurrentDeleteFollowData = {
    body?: never;
    path: {
        /**
         * username of user to unfollow
         */
        username: string;
    };
    query?: never;
    url: '/user/following/{username}';
};

export type UserCurrentDeleteFollowErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentDeleteFollowError = UserCurrentDeleteFollowErrors[keyof UserCurrentDeleteFollowErrors];

export type UserCurrentDeleteFollowResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentCheckFollowingData = {
    body?: never;
    path: {
        /**
         * username of followed user
         */
        username: string;
    };
    query?: never;
    url: '/user/following/{username}';
};

export type UserCurrentCheckFollowingErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentCheckFollowingError = UserCurrentCheckFollowingErrors[keyof UserCurrentCheckFollowingErrors];

export type UserCurrentCheckFollowingResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentPutFollowData = {
    body?: never;
    path: {
        /**
         * username of user to follow
         */
        username: string;
    };
    query?: never;
    url: '/user/following/{username}';
};

export type UserCurrentPutFollowErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentPutFollowError = UserCurrentPutFollowErrors[keyof UserCurrentPutFollowErrors];

export type UserCurrentPutFollowResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type GetVerificationTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/gpg_key_token';
};

export type GetVerificationTokenErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type GetVerificationTokenError = GetVerificationTokenErrors[keyof GetVerificationTokenErrors];

export type GetVerificationTokenResponses = {
    /**
     * APIString is a string response
     */
    200: string;
};

export type GetVerificationTokenResponse = GetVerificationTokenResponses[keyof GetVerificationTokenResponses];

export type UserVerifyGpgKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/gpg_key_verify';
};

export type UserVerifyGpgKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserVerifyGpgKeyError = UserVerifyGpgKeyErrors[keyof UserVerifyGpgKeyErrors];

export type UserVerifyGpgKeyResponses = {
    /**
     * GPGKey
     */
    201: GpgKey;
};

export type UserVerifyGpgKeyResponse = UserVerifyGpgKeyResponses[keyof UserVerifyGpgKeyResponses];

export type UserCurrentListGpgKeysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/gpg_keys';
};

export type UserCurrentListGpgKeysErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentListGpgKeysError = UserCurrentListGpgKeysErrors[keyof UserCurrentListGpgKeysErrors];

export type UserCurrentListGpgKeysResponses = {
    /**
     * GPGKeyList
     */
    200: Array<GpgKey>;
};

export type UserCurrentListGpgKeysResponse = UserCurrentListGpgKeysResponses[keyof UserCurrentListGpgKeysResponses];

export type UserCurrentPostGpgKeyData = {
    body?: CreateGpgKeyOption;
    path?: never;
    query?: never;
    url: '/user/gpg_keys';
};

export type UserCurrentPostGpgKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserCurrentPostGpgKeyError = UserCurrentPostGpgKeyErrors[keyof UserCurrentPostGpgKeyErrors];

export type UserCurrentPostGpgKeyResponses = {
    /**
     * GPGKey
     */
    201: GpgKey;
};

export type UserCurrentPostGpgKeyResponse = UserCurrentPostGpgKeyResponses[keyof UserCurrentPostGpgKeyResponses];

export type UserCurrentDeleteGpgKeyData = {
    body?: never;
    path: {
        /**
         * id of key to delete
         */
        id: number;
    };
    query?: never;
    url: '/user/gpg_keys/{id}';
};

export type UserCurrentDeleteGpgKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentDeleteGpgKeyError = UserCurrentDeleteGpgKeyErrors[keyof UserCurrentDeleteGpgKeyErrors];

export type UserCurrentDeleteGpgKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentGetGpgKeyData = {
    body?: never;
    path: {
        /**
         * id of key to get
         */
        id: number;
    };
    query?: never;
    url: '/user/gpg_keys/{id}';
};

export type UserCurrentGetGpgKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentGetGpgKeyError = UserCurrentGetGpgKeyErrors[keyof UserCurrentGetGpgKeyErrors];

export type UserCurrentGetGpgKeyResponses = {
    /**
     * GPGKey
     */
    200: GpgKey;
};

export type UserCurrentGetGpgKeyResponse = UserCurrentGetGpgKeyResponses[keyof UserCurrentGetGpgKeyResponses];

export type UserListHooksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/hooks';
};

export type UserListHooksErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListHooksError = UserListHooksErrors[keyof UserListHooksErrors];

export type UserListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type UserListHooksResponse = UserListHooksResponses[keyof UserListHooksResponses];

export type UserCreateHookData = {
    body: CreateHookOption;
    path?: never;
    query?: never;
    url: '/user/hooks';
};

export type UserCreateHookErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCreateHookError = UserCreateHookErrors[keyof UserCreateHookErrors];

export type UserCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type UserCreateHookResponse = UserCreateHookResponses[keyof UserCreateHookResponses];

export type UserDeleteHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/user/hooks/{id}';
};

export type UserDeleteHookErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserDeleteHookError = UserDeleteHookErrors[keyof UserDeleteHookErrors];

export type UserDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserGetHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/user/hooks/{id}';
};

export type UserGetHookErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserGetHookError = UserGetHookErrors[keyof UserGetHookErrors];

export type UserGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type UserGetHookResponse = UserGetHookResponses[keyof UserGetHookResponses];

export type UserEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * id of the hook to update
         */
        id: number;
    };
    query?: never;
    url: '/user/hooks/{id}';
};

export type UserEditHookErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserEditHookError = UserEditHookErrors[keyof UserEditHookErrors];

export type UserEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type UserEditHookResponse = UserEditHookResponses[keyof UserEditHookResponses];

export type UserCurrentListKeysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * fingerprint of the key
         */
        fingerprint?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/keys';
};

export type UserCurrentListKeysErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentListKeysError = UserCurrentListKeysErrors[keyof UserCurrentListKeysErrors];

export type UserCurrentListKeysResponses = {
    /**
     * PublicKeyList
     */
    200: Array<PublicKey>;
};

export type UserCurrentListKeysResponse = UserCurrentListKeysResponses[keyof UserCurrentListKeysResponses];

export type UserCurrentPostKeyData = {
    body?: CreateKeyOption;
    path?: never;
    query?: never;
    url: '/user/keys';
};

export type UserCurrentPostKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserCurrentPostKeyError = UserCurrentPostKeyErrors[keyof UserCurrentPostKeyErrors];

export type UserCurrentPostKeyResponses = {
    /**
     * PublicKey
     */
    201: PublicKey;
};

export type UserCurrentPostKeyResponse = UserCurrentPostKeyResponses[keyof UserCurrentPostKeyResponses];

export type UserCurrentDeleteKeyData = {
    body?: never;
    path: {
        /**
         * id of key to delete
         */
        id: number;
    };
    query?: never;
    url: '/user/keys/{id}';
};

export type UserCurrentDeleteKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentDeleteKeyError = UserCurrentDeleteKeyErrors[keyof UserCurrentDeleteKeyErrors];

export type UserCurrentDeleteKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentGetKeyData = {
    body?: never;
    path: {
        /**
         * id of key to get
         */
        id: number;
    };
    query?: never;
    url: '/user/keys/{id}';
};

export type UserCurrentGetKeyErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentGetKeyError = UserCurrentGetKeyErrors[keyof UserCurrentGetKeyErrors];

export type UserCurrentGetKeyResponses = {
    /**
     * PublicKey
     */
    200: PublicKey;
};

export type UserCurrentGetKeyResponse = UserCurrentGetKeyResponses[keyof UserCurrentGetKeyResponses];

export type UserListBlockedUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/list_blocked';
};

export type UserListBlockedUsersErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListBlockedUsersError = UserListBlockedUsersErrors[keyof UserListBlockedUsersErrors];

export type UserListBlockedUsersResponses = {
    /**
     * BlockedUserList
     */
    200: Array<BlockedUser>;
};

export type UserListBlockedUsersResponse = UserListBlockedUsersResponses[keyof UserListBlockedUsersResponses];

export type OrgListCurrentUserOrgsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/orgs';
};

export type OrgListCurrentUserOrgsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListCurrentUserOrgsError = OrgListCurrentUserOrgsErrors[keyof OrgListCurrentUserOrgsErrors];

export type OrgListCurrentUserOrgsResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type OrgListCurrentUserOrgsResponse = OrgListCurrentUserOrgsResponses[keyof OrgListCurrentUserOrgsResponses];

export type UserGetQuotaData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/quota';
};

export type UserGetQuotaErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserGetQuotaError = UserGetQuotaErrors[keyof UserGetQuotaErrors];

export type UserGetQuotaResponses = {
    /**
     * QuotaInfo
     */
    200: QuotaInfo;
};

export type UserGetQuotaResponse = UserGetQuotaResponses[keyof UserGetQuotaResponses];

export type UserListQuotaArtifactsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/quota/artifacts';
};

export type UserListQuotaArtifactsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListQuotaArtifactsError = UserListQuotaArtifactsErrors[keyof UserListQuotaArtifactsErrors];

export type UserListQuotaArtifactsResponses = {
    /**
     * QuotaUsedArtifactList
     */
    200: QuotaUsedArtifactList;
};

export type UserListQuotaArtifactsResponse = UserListQuotaArtifactsResponses[keyof UserListQuotaArtifactsResponses];

export type UserListQuotaAttachmentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/quota/attachments';
};

export type UserListQuotaAttachmentsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListQuotaAttachmentsError = UserListQuotaAttachmentsErrors[keyof UserListQuotaAttachmentsErrors];

export type UserListQuotaAttachmentsResponses = {
    /**
     * QuotaUsedAttachmentList
     */
    200: QuotaUsedAttachmentList;
};

export type UserListQuotaAttachmentsResponse = UserListQuotaAttachmentsResponses[keyof UserListQuotaAttachmentsResponses];

export type UserCheckQuotaData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/quota/check';
};

export type UserCheckQuotaErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserCheckQuotaError = UserCheckQuotaErrors[keyof UserCheckQuotaErrors];

export type UserCheckQuotaResponses = {
    /**
     * Boolean
     */
    200: unknown;
};

export type UserListQuotaPackagesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/quota/packages';
};

export type UserListQuotaPackagesErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListQuotaPackagesError = UserListQuotaPackagesErrors[keyof UserListQuotaPackagesErrors];

export type UserListQuotaPackagesResponses = {
    /**
     * QuotaUsedPackageList
     */
    200: QuotaUsedPackageList;
};

export type UserListQuotaPackagesResponse = UserListQuotaPackagesResponses[keyof UserListQuotaPackagesResponses];

export type UserCurrentListReposData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * order the repositories
         */
        order_by?: 'name' | 'id' | 'newest' | 'oldest' | 'recentupdate' | 'leastupdate' | 'reversealphabetically' | 'alphabetically' | 'reversesize' | 'size' | 'reversegitsize' | 'gitsize' | 'reverselfssize' | 'lfssize' | 'moststars' | 'feweststars' | 'mostforks' | 'fewestforks';
    };
    url: '/user/repos';
};

export type UserCurrentListReposErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserCurrentListReposError = UserCurrentListReposErrors[keyof UserCurrentListReposErrors];

export type UserCurrentListReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserCurrentListReposResponse = UserCurrentListReposResponses[keyof UserCurrentListReposResponses];

export type CreateCurrentUserRepoData = {
    body?: CreateRepoOption;
    path?: never;
    query?: never;
    url: '/user/repos';
};

export type CreateCurrentUserRepoErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * QuotaExceeded
     */
    413: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type CreateCurrentUserRepoError = CreateCurrentUserRepoErrors[keyof CreateCurrentUserRepoErrors];

export type CreateCurrentUserRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type CreateCurrentUserRepoResponse = CreateCurrentUserRepoResponses[keyof CreateCurrentUserRepoResponses];

export type GetUserSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type GetUserSettingsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type GetUserSettingsError = GetUserSettingsErrors[keyof GetUserSettingsErrors];

export type GetUserSettingsResponses = {
    /**
     * UserSettings
     */
    200: UserSettings;
};

export type GetUserSettingsResponse = GetUserSettingsResponses[keyof GetUserSettingsResponses];

export type UpdateUserSettingsData = {
    body?: UserSettingsOptions;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type UpdateUserSettingsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UpdateUserSettingsError = UpdateUserSettingsErrors[keyof UpdateUserSettingsErrors];

export type UpdateUserSettingsResponses = {
    /**
     * UserSettings
     */
    200: UserSettings;
};

export type UpdateUserSettingsResponse = UpdateUserSettingsResponses[keyof UpdateUserSettingsResponses];

export type UserCurrentListStarredData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/starred';
};

export type UserCurrentListStarredErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentListStarredError = UserCurrentListStarredErrors[keyof UserCurrentListStarredErrors];

export type UserCurrentListStarredResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserCurrentListStarredResponse = UserCurrentListStarredResponses[keyof UserCurrentListStarredResponses];

export type UserCurrentDeleteStarData = {
    body?: never;
    path: {
        /**
         * owner of the repo to unstar
         */
        owner: string;
        /**
         * name of the repo to unstar
         */
        repo: string;
    };
    query?: never;
    url: '/user/starred/{owner}/{repo}';
};

export type UserCurrentDeleteStarErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentDeleteStarError = UserCurrentDeleteStarErrors[keyof UserCurrentDeleteStarErrors];

export type UserCurrentDeleteStarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentCheckStarringData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/user/starred/{owner}/{repo}';
};

export type UserCurrentCheckStarringErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentCheckStarringError = UserCurrentCheckStarringErrors[keyof UserCurrentCheckStarringErrors];

export type UserCurrentCheckStarringResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentPutStarData = {
    body?: never;
    path: {
        /**
         * owner of the repo to star
         */
        owner: string;
        /**
         * name of the repo to star
         */
        repo: string;
    };
    query?: never;
    url: '/user/starred/{owner}/{repo}';
};

export type UserCurrentPutStarErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCurrentPutStarError = UserCurrentPutStarErrors[keyof UserCurrentPutStarErrors];

export type UserCurrentPutStarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserGetStopWatchesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/stopwatches';
};

export type UserGetStopWatchesErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserGetStopWatchesError = UserGetStopWatchesErrors[keyof UserGetStopWatchesErrors];

export type UserGetStopWatchesResponses = {
    /**
     * StopWatchList
     */
    200: Array<StopWatch>;
};

export type UserGetStopWatchesResponse = UserGetStopWatchesResponses[keyof UserGetStopWatchesResponses];

export type UserCurrentListSubscriptionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/subscriptions';
};

export type UserCurrentListSubscriptionsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentListSubscriptionsError = UserCurrentListSubscriptionsErrors[keyof UserCurrentListSubscriptionsErrors];

export type UserCurrentListSubscriptionsResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserCurrentListSubscriptionsResponse = UserCurrentListSubscriptionsResponses[keyof UserCurrentListSubscriptionsResponses];

export type UserListTeamsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/teams';
};

export type UserListTeamsErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserListTeamsError = UserListTeamsErrors[keyof UserListTeamsErrors];

export type UserListTeamsResponses = {
    /**
     * TeamList
     */
    200: Array<Team>;
};

export type UserListTeamsResponse = UserListTeamsResponses[keyof UserListTeamsResponses];

export type UserCurrentTrackedTimesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * Only show times updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show times updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
    };
    url: '/user/times';
};

export type UserCurrentTrackedTimesErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
};

export type UserCurrentTrackedTimesError = UserCurrentTrackedTimesErrors[keyof UserCurrentTrackedTimesErrors];

export type UserCurrentTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type UserCurrentTrackedTimesResponse = UserCurrentTrackedTimesResponses[keyof UserCurrentTrackedTimesResponses];

export type UserUnblockUserData = {
    body?: never;
    path: {
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/user/unblock/{username}';
};

export type UserUnblockUserErrors = {
    /**
     * APIUnauthorizedError is a unauthorized error response
     */
    401: ApiUnauthorizedError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: ApiValidationError;
};

export type UserUnblockUserError = UserUnblockUserErrors[keyof UserUnblockUserErrors];

export type UserUnblockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserSearchData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * keyword
         */
        q?: string;
        /**
         * ID of the user to search for
         */
        uid?: number;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/search';
};

export type UserSearchResponses = {
    /**
     * SearchResults of a successful search
     */
    200: {
        data?: Array<User>;
        ok?: boolean;
    };
};

export type UserSearchResponse = UserSearchResponses[keyof UserSearchResponses];

export type UserGetData = {
    body?: never;
    path: {
        /**
         * username of user to get
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}';
};

export type UserGetErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserGetError = UserGetErrors[keyof UserGetErrors];

export type UserGetResponses = {
    /**
     * User
     */
    200: User;
};

export type UserGetResponse = UserGetResponses[keyof UserGetResponses];

export type UserListActivityFeedsData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * if true, only show actions performed by the requested user
         */
        'only-performed-by'?: boolean;
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/activities/feeds';
};

export type UserListActivityFeedsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListActivityFeedsError = UserListActivityFeedsErrors[keyof UserListActivityFeedsErrors];

export type UserListActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type UserListActivityFeedsResponse = UserListActivityFeedsResponses[keyof UserListActivityFeedsResponses];

export type UserListFollowersData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/followers';
};

export type UserListFollowersErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListFollowersError = UserListFollowersErrors[keyof UserListFollowersErrors];

export type UserListFollowersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserListFollowersResponse = UserListFollowersResponses[keyof UserListFollowersResponses];

export type UserListFollowingData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/following';
};

export type UserListFollowingErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListFollowingError = UserListFollowingErrors[keyof UserListFollowingErrors];

export type UserListFollowingResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserListFollowingResponse = UserListFollowingResponses[keyof UserListFollowingResponses];

export type UserCheckFollowingData = {
    body?: never;
    path: {
        /**
         * username of following user
         */
        username: string;
        /**
         * username of followed user
         */
        target: string;
    };
    query?: never;
    url: '/users/{username}/following/{target}';
};

export type UserCheckFollowingErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCheckFollowingError = UserCheckFollowingErrors[keyof UserCheckFollowingErrors];

export type UserCheckFollowingResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserListGpgKeysData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/gpg_keys';
};

export type UserListGpgKeysErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListGpgKeysError = UserListGpgKeysErrors[keyof UserListGpgKeysErrors];

export type UserListGpgKeysResponses = {
    /**
     * GPGKeyList
     */
    200: Array<GpgKey>;
};

export type UserListGpgKeysResponse = UserListGpgKeysResponses[keyof UserListGpgKeysResponses];

export type UserGetHeatmapDataData = {
    body?: never;
    path: {
        /**
         * username of user to get
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}/heatmap';
};

export type UserGetHeatmapDataErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserGetHeatmapDataError = UserGetHeatmapDataErrors[keyof UserGetHeatmapDataErrors];

export type UserGetHeatmapDataResponses = {
    /**
     * UserHeatmapData
     */
    200: Array<UserHeatmapData>;
};

export type UserGetHeatmapDataResponse = UserGetHeatmapDataResponses[keyof UserGetHeatmapDataResponses];

export type UserListKeysData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * fingerprint of the key
         */
        fingerprint?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/keys';
};

export type UserListKeysErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListKeysError = UserListKeysErrors[keyof UserListKeysErrors];

export type UserListKeysResponses = {
    /**
     * PublicKeyList
     */
    200: Array<PublicKey>;
};

export type UserListKeysResponse = UserListKeysResponses[keyof UserListKeysResponses];

export type OrgListUserOrgsData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/orgs';
};

export type OrgListUserOrgsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgListUserOrgsError = OrgListUserOrgsErrors[keyof OrgListUserOrgsErrors];

export type OrgListUserOrgsResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type OrgListUserOrgsResponse = OrgListUserOrgsResponses[keyof OrgListUserOrgsResponses];

export type OrgGetUserPermissionsData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/users/{username}/orgs/{org}/permissions';
};

export type OrgGetUserPermissionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type OrgGetUserPermissionsError = OrgGetUserPermissionsErrors[keyof OrgGetUserPermissionsErrors];

export type OrgGetUserPermissionsResponses = {
    /**
     * OrganizationPermissions
     */
    200: OrganizationPermissions;
};

export type OrgGetUserPermissionsResponse = OrgGetUserPermissionsResponses[keyof OrgGetUserPermissionsResponses];

export type UserListReposData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/repos';
};

export type UserListReposErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListReposError = UserListReposErrors[keyof UserListReposErrors];

export type UserListReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserListReposResponse = UserListReposResponses[keyof UserListReposResponses];

export type UserListStarredData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/starred';
};

export type UserListStarredErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListStarredError = UserListStarredErrors[keyof UserListStarredErrors];

export type UserListStarredResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserListStarredResponse = UserListStarredResponses[keyof UserListStarredResponses];

export type UserListSubscriptionsData = {
    body?: never;
    path: {
        /**
         * username of the user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/subscriptions';
};

export type UserListSubscriptionsErrors = {
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserListSubscriptionsError = UserListSubscriptionsErrors[keyof UserListSubscriptionsErrors];

export type UserListSubscriptionsResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserListSubscriptionsResponse = UserListSubscriptionsResponses[keyof UserListSubscriptionsResponses];

export type UserGetTokensData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/tokens';
};

export type UserGetTokensErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserGetTokensError = UserGetTokensErrors[keyof UserGetTokensErrors];

export type UserGetTokensResponses = {
    /**
     * AccessTokenList represents a list of API access token.
     */
    200: Array<AccessToken>;
};

export type UserGetTokensResponse = UserGetTokensResponses[keyof UserGetTokensResponses];

export type UserCreateTokenData = {
    body?: CreateAccessTokenOption;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}/tokens';
};

export type UserCreateTokenErrors = {
    /**
     * APIError is error format response
     */
    400: ApiError;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
};

export type UserCreateTokenError = UserCreateTokenErrors[keyof UserCreateTokenErrors];

export type UserCreateTokenResponses = {
    /**
     * AccessToken represents an API access token.
     */
    201: AccessToken;
};

export type UserCreateTokenResponse = UserCreateTokenResponses[keyof UserCreateTokenResponses];

export type UserDeleteAccessTokenData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
        /**
         * token to be deleted, identified by ID and if not available by name
         */
        token: string;
    };
    query?: never;
    url: '/users/{username}/tokens/{token}';
};

export type UserDeleteAccessTokenErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: ApiForbiddenError;
    /**
     * APINotFound is a not found error response
     */
    404: ApiNotFound;
    /**
     * APIError is error format response
     */
    422: ApiError;
};

export type UserDeleteAccessTokenError = UserDeleteAccessTokenErrors[keyof UserDeleteAccessTokenErrors];

export type UserDeleteAccessTokenResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type GetVersionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/version';
};

export type GetVersionResponses = {
    /**
     * ServerVersion
     */
    200: ServerVersion;
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];
